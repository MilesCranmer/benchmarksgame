<!DOCTYPE html>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="robots" content="noindex,follow,noarchive">

<title>reverse-complement OCaml Flambda&nbsp;#4 program | Computer Language Benchmarks Game </title>
<style><!--
a{color:black;text-decoration:none}article{padding:0 0 2.9em}article,div,footer,header{margin:auto;width:92%}body{font:100% Droid Sans, Ubuntu, Verdana, sans-serif;margin:0;-webkit-text-size-adjust:100%}h3, h1, h2, li a{font-family:Ubuntu Mono,Consolas,Menlo,monospace}div,footer,header{max-width:31em}footer{padding:2.6em 0 0}h3{font-size:1.4em;font-weight:bold;margin:0;padding: .4em}h3, h3 a{color:white;background-color:#77216f}h3 small{font-size:0.64em}h1,h2{margin:1.5em 0 0}h1{font-size:1.4em;font-weight:normal}h2{font-size:1.2em}li{list-style-type:none;vertical-align:top}li a{display:block;font-size:1.2em;margin: .5em .5em 0;padding: .5em .5em .3em}ul{clear:left;margin:-0.3em 0 1.5em;padding-left:0;text-align:center}p{color:#333;line-height:1.4;margin: .3em 0 0}p a, a span{border-bottom: .1em solid #333;padding-bottom: .1em}.com,.slc{color:#888}.kwa{color:#066}.kwb{color:#900}.kwc{color:#050}.kwa,.kwb,.kwc{font-weight:bold}.dstr,.str,.sym,.num{color:#930}pre{color:#222;font-size:1em;overflow-wrap:break-word;white-space:pre-wrap;word-wrap:break-word}@media only screen and (min-width: 60em){article,footer,header{font-size:1.25em}}
--></style>
<link rel="shortcut icon" href="./favicon.ico">
<header>
  <h3><a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/">The&nbsp;<small>Computer&nbsp;Language</small><br>Benchmarks&nbsp;Game</a></h3>
</header>
<article>
  <div>
    <h1>reverse-complement OCaml Flambda&nbsp;#4 program</h1>
    <aside>
      <p><a href="../description/revcomp.html#revcomp">description</a>
    </aside>
  </div>
  <section>
    <div>
      <h2>source code</h2>
    </div>
    <pre>
(* The Computer Language Benchmarks Game
 * https://salsa.debian.org/benchmarksgame-team/benchmarksgame/

   contributed by Ingo Bormuth
   modified by Fabrice Le Fessant 
*)

let verbose = false

let rec print_args list =
  match list with
      [] -&gt; ()
    | x :: tail -&gt;
	Printf.fprintf stderr &quot; %d&quot; x;
	print_args tail

let enter name list =
  if verbose then begin
    Printf.fprintf stderr &quot;%s:&quot; name;
    print_args list;
    Printf.fprintf stderr &quot;\n%!&quot;
  end

let arch64 =
  match Sys.word_size with
      32 -&gt; false
    | 64 -&gt; true
    | _ -&gt; assert false


module LineReader : sig

  (* read all non empty lines *)
  val read :
    (* from : *) Unix.file_descr -&gt;
    (* max_line_length : *) int -&gt;
    (* handler : *) (string -&gt; int -&gt; int -&gt; unit) -&gt; unit

end = struct

  let read ic maxlen handler =
    let s = String.create maxlen in

    let rec iter begin_pos pos =
      let to_read = maxlen - pos in
	if to_read &lt; 32000 then begin
	  let len = pos - begin_pos in
	    String.blit s begin_pos s 0 len;
	    iter 0 len
	end else
	  let nread = Unix.read ic s pos to_read in
	if nread = 0 then raise End_of_file;
	let end_pos = pos + nread in
	iter2 begin_pos pos end_pos

    and iter2 begin_pos pos end_pos =
      if pos = end_pos then
	iter begin_pos end_pos
      else
	match s.[pos] with
	    &apos;\n&apos; | &apos;\r&apos; -&gt;
	      if pos &gt; begin_pos then
		handler s begin_pos (pos - begin_pos);
	      iter2 (pos+1) (pos+1) end_pos
	  | _ -&gt;
	      iter2 begin_pos (pos+1) end_pos

    in
      iter 0 0

end

let t = String.make 256 &apos; &apos;
let b = String.make 61 &apos;\n&apos;
let bi = ref 1
let _ =
  String.blit &quot;TVGHEFCDIJMLKNOPQYSAABWXRZ&quot; 0 t 65 26;
  String.blit t 65 t 97 26
;;

let t =
  let s = Array.create 256 &apos; &apos; in
    for i = 0 to 255 do
      s.(i) &lt;- t.[i]
    done;
    s
;;

module Fasta : sig

  val clear : unit -&gt; unit
  val flush : unit -&gt; unit
  val print : string -&gt; int -&gt; int -&gt; unit

end = struct

  let printed = ref 0

  let clear () = printed := 0
  let flush () =
    if !printed &gt; 0 then print_newline ();
    printed := 0

  let rec print s pos len =
    if len &gt; 60 then begin
      output stdout s pos 60;
      output_char stdout &apos;\n&apos;;
      print s (pos + 60) (len-60)
    end else
      if len &gt; 0 then
	begin
	  output stdout s pos len;
	  printed := len
	end

  let print s pos len =
    let to_print = 60 - !printed in
      if len &lt; to_print then begin
	output stdout s pos len;
	printed := !printed + len
      end else begin
	output stdout s pos to_print;
	output_char stdout &apos;\n&apos;;
	printed := 0;
	print s (pos + to_print) (len - to_print);
      end

end

module IMPLEMENTATION32 : sig
  val main : unit -&gt; unit
end = struct

module BigRevBuffer : sig

  val clear : unit -&gt; unit
  val length : unit -&gt; int
  val add : string -&gt; int -&gt; int -&gt; unit
(*  val iter : (string -&gt; int -&gt; int -&gt; unit) -&gt; unit *)
  val reverse_iter : unit -&gt; unit

end = struct

(* don&apos;t allocate any buffers on x64 *)
  let nbuffers = if arch64 then 0 else 256


  let buffer_len = 1_000_000

  let buffers = Array.init nbuffers (fun _ -&gt; String.create buffer_len)
  let buffer_pos = Array.create nbuffers buffer_len
  let last_buffer = ref 0

  let clear () =
    last_buffer := 0;
    for i = 0 to 255 do
      buffer_pos.(i) &lt;- buffer_len;
    done

  let length () =
    !last_buffer * buffer_len + (buffer_len - buffer_pos.(!last_buffer))

  let rec blit_rev src end_pos dst dpos len =
    if len &gt; 0 then begin
      dst.[dpos] &lt;- t.(Char.code  src.[end_pos]);
      blit_rev src (end_pos-1) dst (dpos+1) (len-1)
    end

  let blit_rev src spos dst dpos len =
    let end_pos = spos + len - 1 in
    blit_rev src end_pos dst dpos len

  let rec add s pos len =
    if len &gt; 0 then
      let b = buffers.(!last_buffer) in
      let bpos = buffer_pos.(!last_buffer) in
	if bpos &gt; len then begin
	  let new_pos = bpos - len in
	    blit_rev s pos b new_pos len;
	    buffer_pos.(!last_buffer) &lt;- new_pos
	end else begin
	  blit_rev s pos b 0 bpos;
	  buffer_pos.(!last_buffer) &lt;- 0;
	  incr last_buffer;
	  add s (pos + bpos) (len - bpos)
	end

(*

  let iter f =
    let rec iter f i last_buffer =
      if i &lt; last_buffer then begin
	f  buffers.(i) 0 buffer_len;
	iter f (i+1) last_buffer
      end
      else
	let pos = buffer_pos.(last_buffer) in
	  f buffers.(last_buffer) pos (buffer_len - pos)
    in
      iter f 0 !last_buffer

  let rev_iter f =
    let rec iter f i =
      if i &gt;= 0 then begin
	f  buffers.(i) 0 buffer_len;
	iter f (i-1)
      end
    in
    let pos = buffer_pos.(!last_buffer) in
      f buffers.(!last_buffer) pos (buffer_len - pos);
      iter f (!last_buffer-1)
*)

  let reverse_iter f =
    let rec iter i =
      if i &gt;= 0 then begin
	Fasta.print  buffers.(i) 0 buffer_len;
	iter (i-1)
      end
    in
    let pos = buffer_pos.(!last_buffer) in
      if pos &lt; buffer_len then
	Fasta.print buffers.(!last_buffer) pos (buffer_len - pos);
      iter (!last_buffer-1)

end

let reverse () =
  if BigRevBuffer.length () &gt; 0 then begin
    Fasta.clear ();
    BigRevBuffer.reverse_iter ();
    BigRevBuffer.clear ();
    Fasta.flush ()
  end

let main () =
  try
    LineReader.read Unix.stdin 1_000_000
      (fun s pos len -&gt;
	 if s.[pos] = &apos;&gt;&apos; then begin
	   reverse ();
	   output stdout s pos len;
	   output_char stdout &apos;\n&apos;;
	 end else
	   BigRevBuffer.add s pos len
      )
  with End_of_file -&gt; reverse ()
    | e -&gt;
	Printf.fprintf stderr &quot;exception %s\n%!&quot; (Printexc.to_string e);
	exit 2

end

module IMPLEMENTATION64 : sig

  val main : unit -&gt; unit

end = struct

  let buffer_len = 150_000_000

  let buffer = if arch64 then String.create buffer_len else &quot;&quot;
  let buffer_pos = ref buffer_len

  let wait_for = ref None

  let reverse () =
    begin
      match !wait_for with
	  None -&gt; ()
	| Some ix -&gt;
	    let s = String.create 1 in
	    ignore (Unix.read ix s 0 1)
    end;
    let len = buffer_len - !buffer_pos in
      if len &gt; 0 then begin
	Fasta.clear ();
	Fasta.print buffer !buffer_pos len;
	Fasta.flush ();
	buffer_pos := buffer_len;
      end

    let maxlen = 10_000_000
    let inbuf = String.create maxlen

let rec iter1 begin_pos () pos =
  let to_read = maxlen - pos in
    if to_read &lt; 32_000 then begin
      let len = pos - begin_pos in
	String.blit inbuf begin_pos inbuf 0 len;
	iter1 0 () len
    end else
      let nread = Unix.read Unix.stdin inbuf pos to_read in
	if nread = 0 then raise End_of_file;
	let end_pos = pos + nread in
	  iter2 begin_pos pos end_pos

and iter2 begin_pos pos end_pos =
  if pos = end_pos then
    iter1 begin_pos () end_pos
  else
    match inbuf.[pos] with
	&apos;\n&apos; -&gt;
	  iter2 (pos+1) (pos+1) end_pos
      | &apos;&gt;&apos; -&gt;
	  iter4 begin_pos (pos+1) end_pos
      | c -&gt;
	  let c = t.(Char.code c) in
	    decr buffer_pos;
	    buffer.[!buffer_pos] &lt;- c;
	    iter2 begin_pos (pos+1) end_pos

and iter3 begin_pos () pos =
  let to_read = maxlen - pos in
    if to_read &lt; 32000 then begin
      let len = pos - begin_pos in
	String.blit inbuf begin_pos inbuf 0 len;
	iter3 0 () len
    end else
      let nread = Unix.read Unix.stdin inbuf pos to_read in
	if nread = 0 then raise End_of_file;
	let end_pos = pos + nread in
	  iter4 begin_pos pos end_pos

and iter4 begin_pos pos end_pos =
  if pos = end_pos then
    iter3 begin_pos () end_pos
  else
    match inbuf.[pos] with
	&apos;\n&apos; | &apos;\r&apos; -&gt;
	  if pos &gt; begin_pos then begin
	    if !buffer_pos &lt; buffer_len then begin
	      let (ix, ox) = Unix.pipe () in
		match Unix.fork () with
		  | -1 -&gt; assert false
		  | 0 -&gt;
		      reverse ();
		      output stdout inbuf begin_pos (pos - begin_pos);
		      output_char stdout &apos;\n&apos;;
		      ignore (Unix.write ox &quot;X&quot; 0 1);
		      Unix.close ox;
		      exit 0;
		  | _ -&gt;
		      wait_for := Some ix;
		      buffer_pos := buffer_len;
	    end else begin
	      output stdout inbuf begin_pos (pos - begin_pos);
	      output_char stdout &apos;\n&apos;;
	      flush stdout;
	    end
	  end;
	  iter2 (pos+1) (pos+1) end_pos
      | _ -&gt;
	  iter4 begin_pos (pos+1) end_pos

let read () =
    iter1 0 () 0

let main () =
  enter &quot;main64&quot; [];
  try
    read ()
  with End_of_file -&gt; reverse ()
    | e -&gt;
	Printf.fprintf stderr &quot;exception %s\n%!&quot; (Printexc.to_string e);
	exit 2

end

let _ =
  if arch64 then
    IMPLEMENTATION64.main ()
  else
    IMPLEMENTATION32.main ()
    </pre>
  </section>
  <section>
    <div>
      <h2 id="log">notes, command-line, and program output</h2>
    </div>
    <pre>
NOTES:
64-bit Ubuntu quad core
The OCaml native-code compiler, version 4.10.0


Mon, 03 Aug 2020 22:28:08 GMT

MAKE:
mv revcomp.ocamlflambda-4.ocamlflambda revcomp.ocamlflambda-4.ml
~/.opam/4.10.0+flambda/bin/ocamlopt -noassert -unsafe -fPIC -nodynlink -inline 100 -O3 unix.cmxa -ccopt -march=ivybridge revcomp.ocamlflambda-4.ml -o revcomp.ocamlflambda-4.ocamlflambda_run
File &quot;revcomp.ocamlflambda-4.ml&quot;, line 42, characters 12-25:
42 |     let s = String.create maxlen in
                 ^^^^^^^^^^^^^
Alert deprecated: Stdlib.String.create
Use Bytes.create instead.
File &quot;revcomp.ocamlflambda-4.ml&quot;, line 48, characters 17-18:
48 | 	    String.blit s begin_pos s 0 len;
                      ^
Error: This expression has type bytes but an expression was expected of type
         string
make: [/home/dunham/all-benchmarksgame/2000-benchmarksgame/nanobench/makefiles/u64q.programs.Makefile:331: revcomp.ocamlflambda-4.ocamlflambda_run] Error 2 (ignored)
rm revcomp.ocamlflambda-4.ml

0.57s to complete and log all make actions

COMMAND LINE:
./revcomp.ocamlflambda-4.ocamlflambda_run 0 &lt; revcomp-input250000.txt

MAKE ERROR 

    </pre>
  </section>
</article>
<footer>
  <nav>
    <ul>
      <li><a href="https://salsa.debian.org/benchmarksgame-team/benchmarksgame/blob/master/CONTRIBUTING.md#contribute-source-code-for-measurement"><span>Contribute your own program</span></a>
      <li><a href="../license.html"><span>3-Clause BSD License</span></a>
    </ul>
  </nav>
</footer>

