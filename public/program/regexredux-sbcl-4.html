<!DOCTYPE html>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="robots" content="noindex,follow,noarchive">

<title>regex-redux Lisp SBCL&nbsp;#4 program | Computer Language Benchmarks Game </title>
<style><!--
a{color:black;text-decoration:none}article{padding:0 0 2.9em}article,div,footer,header{margin:auto;width:92%}body{font:100% Droid Sans, Ubuntu, Verdana, sans-serif;margin:0;-webkit-text-size-adjust:100%}h3, h1, h2, li a{font-family:Ubuntu Mono,Consolas,Menlo,monospace}div,footer,header{max-width:31em}footer{padding:2.6em 0 0}h3{font-size:1.4em;font-weight:bold;margin:0;padding: .4em}h3, h3 a{color:white;background-color:#77216f}h3 small{font-size:0.64em}h1,h2{margin:1.5em 0 0}h1{font-size:1.4em;font-weight:normal}h2{font-size:1.2em}li{list-style-type:none;vertical-align:top}li a{display:block;font-size:1.2em;margin: .5em .5em 0;padding: .5em .5em .3em}ul{clear:left;margin:-0.3em 0 1.5em;padding-left:0;text-align:center}p{color:#333;line-height:1.4;margin: .3em 0 0}p a, a span{border-bottom: .1em solid #333;padding-bottom: .1em}.com,.slc{color:#888}.kwa{color:#066}.kwb{color:#900}.kwc{color:#050}.kwa,.kwb,.kwc{font-weight:bold}.dstr,.str,.sym,.num{color:#930}pre{color:#222;font-size:1em;overflow-wrap:break-word;white-space:pre-wrap;word-wrap:break-word}@media only screen and (min-width: 60em){article,footer,header{font-size:1.25em}}
--></style>
<link rel="shortcut icon" href="../favicon.ico">
<header>
  <h3><a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/index.html">The&nbsp;<small>Computer&nbsp;Language</small><br>Benchmarks&nbsp;Game</a></h3>
</header>
<article>
  <div>
    <h1>regex-redux Lisp SBCL&nbsp;#4 program</h1>
    <aside>
      <p><a href="../description/regexredux.html#regexredux">description</a>
    </aside>
  </div>
  <section>
    <div>
      <h2>source code</h2>
    </div>
    <pre>
<span class="slc">;;; The Computer Language Benchmarks Game</span>
<span class="slc">;;; https://salsa.debian.org/benchmarksgame-team/benchmarksgame/</span>
<span class="slc">;;;</span>
<span class="slc">;;; regex-dna program contributed by: Witali Kusnezow 2009-03-02</span>
<span class="slc">;;; converted from regex-dna program</span>
<span class="slc">;;; fixed by Antonio Saade</span>

<span class="opt">(</span><span class="kwa">eval-when</span> <span class="opt">(:</span>compile-toplevel <span class="opt">:</span>load-toplevel <span class="opt">:</span>execute<span class="opt">)</span>
  <span class="opt">(</span><span class="kwa">require</span> <span class="opt">:</span>asdf<span class="opt">)</span>
  <span class="opt">(</span><span class="kwa">require</span> <span class="opt">:</span>cl-ppcre<span class="opt">)</span>

<span class="opt">#+</span>sb-thread
<span class="opt">(</span><span class="kwa">progn</span>
  <span class="opt">(</span><span class="kwa">define-alien-routine</span> sysconf long <span class="opt">(</span><span class="kwa">name</span> int<span class="opt">))</span>
  <span class="opt">(</span><span class="kwa">use-package</span> <span class="opt">:</span>sb-thread<span class="opt">)))</span>

<span class="opt">(</span><span class="kwa">eval-when</span> <span class="opt">(:</span>compile-toplevel<span class="opt">)</span>
<span class="opt">(</span><span class="kwa">setf</span> cl-ppcre<span class="opt">:*</span>regex-char-code-limit<span class="opt">*</span> <span class="num">128</span><span class="opt">))</span>

<span class="opt">(</span><span class="kwa">defconstant</span>  <span class="opt">+</span>regex-list<span class="opt">+</span>
  <span class="opt">&apos;(</span><span class="str">&quot;agggtaaa|tttaccct&quot;</span>
    <span class="str">&quot;[cgt]gggtaaa|tttaccc[acg]&quot;</span>
    <span class="str">&quot;a[act]ggtaaa|tttacc[agt]t&quot;</span>
    <span class="str">&quot;ag[act]gtaaa|tttac[agt]ct&quot;</span>
    <span class="str">&quot;agg[act]taaa|ttta[agt]cct&quot;</span>
    <span class="str">&quot;aggg[acg]aaa|ttt[cgt]ccct&quot;</span>
    <span class="str">&quot;agggt[cgt]aa|tt[acg]accct&quot;</span>
    <span class="str">&quot;agggta[cgt]a|t[acg]taccct&quot;</span>
    <span class="str">&quot;agggtaa[cgt]|[acg]ttaccct&quot;</span><span class="opt">))</span>

<span class="opt">(</span><span class="kwa">defconstant</span>  <span class="opt">+</span>alternatives<span class="opt">+</span>
  <span class="opt">&apos;((</span><span class="str">&quot;tHa[Nt]&quot;</span> <span class="str">&quot;&lt;4&gt;&quot;</span><span class="opt">)  (</span><span class="str">&quot;aND|caN|Ha[DS]|WaS&quot;</span> <span class="str">&quot;&lt;3&gt;&quot;</span><span class="opt">)</span>
    <span class="opt">(</span><span class="str">&quot;a[NSt]|BY&quot;</span> <span class="str">&quot;&lt;2&gt;&quot;</span><span class="opt">)  (</span><span class="str">&quot;&lt;[^&gt;]*&gt;&quot;</span> <span class="str">&quot;|&quot;</span><span class="opt">)</span>
    <span class="opt">(</span><span class="str">&quot;</span><span class="esc">\\</span><span class="str">|[^|][^|]*</span><span class="esc">\\</span><span class="str">|&quot;</span> <span class="str">&quot;-&quot;</span><span class="opt">)))</span>

<span class="opt">#+</span>sb-thread
<span class="opt">(</span><span class="kwa">progn</span>
  <span class="opt">(</span><span class="kwa">defconstant</span>  <span class="opt">+</span>cpu-count<span class="opt">+ (</span><span class="kwa">sysconf</span> <span class="num">84</span><span class="opt">))</span>
  <span class="opt">(</span><span class="kwa">defvar</span> <span class="opt">*</span>mutex<span class="opt">* (</span><span class="kwa">make-mutex</span><span class="opt">))</span>
  <span class="opt">(</span><span class="kwa">defvar</span> <span class="opt">*</span>aux-mutex<span class="opt">* (</span><span class="kwa">make-mutex</span><span class="opt">))</span>

  <span class="opt">(</span><span class="kwa">defmacro</span> bg  <span class="opt">(&amp;</span>body body<span class="opt">) `(</span><span class="kwa">make-thread</span> <span class="opt">(</span><span class="kwa">lambda</span> <span class="opt">() ,&#64;</span>body<span class="opt">)))</span>
  <span class="opt">(</span><span class="kwa">defmacro</span> join-all <span class="opt">(&amp;</span>body body<span class="opt">)</span>
	<span class="opt">`(</span><span class="kwa">mapcar</span>
	  <span class="opt">#&apos;</span>join-thread
	  <span class="opt">(</span><span class="kwa">loop</span> for item in <span class="opt">(</span><span class="kwa">list</span> <span class="opt">,&#64;</span>body<span class="opt">)</span>
		 append <span class="opt">(</span><span class="kwa">if</span> <span class="opt">(</span><span class="kwa">consp</span> item<span class="opt">)</span> item <span class="opt">(</span><span class="kwa">list</span> item<span class="opt">))))))</span>

<span class="opt">(</span><span class="kwa">defun</span> <span class="kwb">read-all</span>
    <span class="opt">(</span><span class="kwa">stream</span> <span class="opt">&amp;</span>aux <span class="opt">(</span><span class="kwa">buf-size</span> <span class="opt">(*</span> <span class="num">1024 1024</span><span class="opt">))</span>
     <span class="opt">(</span><span class="kwa">size</span> <span class="num">0</span><span class="opt">)</span>
     <span class="opt">(</span><span class="kwa">buf-list</span>
      <span class="opt">(</span><span class="kwa">loop</span>
         for buf <span class="opt">= (</span><span class="kwa">make-string</span> buf-size <span class="opt">:</span>element-type <span class="opt">&apos;</span>base-char<span class="opt">)</span>
         for len <span class="opt">= (</span><span class="kwa">read-sequence</span> buf stream<span class="opt">)</span>
         do <span class="opt">(</span><span class="kwa">incf</span> size len<span class="opt">)</span>
         collect <span class="opt">(</span><span class="kwa">if</span> <span class="opt">(&lt;</span> len buf-size<span class="opt">) (</span><span class="kwa">subseq</span> buf <span class="num">0</span> len<span class="opt">)</span> buf<span class="opt">)</span>
         while <span class="opt">(=</span> len buf-size<span class="opt">))))</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">type</span> fixnum size<span class="opt">))</span>
  <span class="opt">(</span><span class="kwa">loop</span> with res-string <span class="opt">= (</span><span class="kwa">make-string</span> size <span class="opt">:</span>element-type <span class="opt">&apos;</span>base-char<span class="opt">)</span>
     with i of-type fixnum <span class="opt">=</span> <span class="num">0</span>
     for str in buf-list
     do <span class="opt">(</span><span class="kwa">setf</span> <span class="opt">(</span><span class="kwa">subseq</span> res-string i<span class="opt">) (</span><span class="kwa">the</span> simple-base-string str<span class="opt">))</span>
     <span class="opt">(</span><span class="kwa">incf</span> i <span class="opt">(</span><span class="kwa">length</span> <span class="opt">(</span><span class="kwa">the</span> simple-base-string str<span class="opt">)))</span>
     finally <span class="opt">(</span><span class="kwa">return</span> res-string<span class="opt">)))</span>

<span class="opt">(</span><span class="kwa">defun</span> <span class="kwb">length-to-replace</span> <span class="opt">(</span><span class="kwa">match</span><span class="opt">)</span>
  <span class="opt">(</span><span class="kwa">loop</span> for x in match
     sum <span class="opt">(</span><span class="kwa">-</span> <span class="opt">(</span><span class="kwa">the</span> fixnum <span class="opt">(</span><span class="kwa">cdr</span> x<span class="opt">))</span>
            <span class="opt">(</span><span class="kwa">the</span> fixnum <span class="opt">(</span><span class="kwa">car</span> x<span class="opt">)))</span> of-type fixnum<span class="opt">))</span>

<span class="opt">(</span><span class="kwa">defun</span> <span class="kwb">replace-aux</span>
    <span class="opt">(</span><span class="kwa">match</span> replacement target-string result-string
     <span class="opt">&amp;</span>key <span class="opt">(</span><span class="kwa">match-begin</span> <span class="num">0</span><span class="opt">) (</span><span class="kwa">match-end</span> -<span class="num">1</span><span class="opt">)</span>
     <span class="opt">(</span><span class="kwa">match-length</span> <span class="opt">(</span><span class="kwa">length</span> match<span class="opt">))</span>
     <span class="opt">&amp;</span>aux
     <span class="opt">(</span><span class="kwa">len</span> <span class="opt">(</span><span class="kwa">length</span> replacement<span class="opt">))</span>
     <span class="opt">(</span><span class="kwa">first-match</span> <span class="opt">(</span><span class="kwa">if</span> <span class="opt">(</span><span class="kwa">zerop</span> match-begin<span class="opt">) &apos;(</span><span class="kwa">0</span> . <span class="num">0</span><span class="opt">) (</span><span class="kwa">nth</span> <span class="opt">(</span><span class="kwa">1-</span> match-begin<span class="opt">)</span> match<span class="opt">)))</span>
     <span class="opt">(</span><span class="kwa">target-start</span> <span class="opt">(</span><span class="kwa">cdr</span> first-match<span class="opt">))</span>
     <span class="opt">(</span><span class="kwa">result-start</span> <span class="opt">(+ (</span><span class="kwa">the</span> fixnum <span class="opt">(*</span> len match-begin<span class="opt">))</span>
                    <span class="opt">(</span><span class="kwa">-</span> target-start
                       <span class="opt">(</span><span class="kwa">the</span> fixnum <span class="opt">(</span><span class="kwa">length-to-replace</span> <span class="opt">(</span><span class="kwa">subseq</span> match <span class="num">0</span> match-begin<span class="opt">)))))))</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">type</span> fixnum match-begin match-end match-length target-start result-start len<span class="opt">)</span>
           <span class="opt">(</span><span class="kwa">type</span> list match<span class="opt">)</span>
           <span class="opt">(</span><span class="kwa">type</span> simple-base-string result-string target-string<span class="opt">)</span>
           <span class="opt">(</span><span class="kwa">type</span> vector replacement<span class="opt">))</span>
  <span class="opt">(</span><span class="kwa">loop</span> with <span class="opt">(</span><span class="kwa">i</span> j<span class="opt">)</span> of-type fixnum <span class="opt">= (</span><span class="kwa">list</span> result-start target-start<span class="opt">)</span>
     with mmatch <span class="opt">= (</span><span class="kwa">if</span> <span class="opt">(&gt;</span> match-begin match-end<span class="opt">)</span>
                       match <span class="opt">(</span><span class="kwa">subseq</span> match match-begin match-end<span class="opt">))</span>
     for pair in mmatch
     do <span class="opt">(</span><span class="kwa">setf</span> <span class="opt">(</span><span class="kwa">subseq</span> result-string i<span class="opt">) (</span><span class="kwa">subseq</span> target-string j <span class="opt">(</span><span class="kwa">car</span> pair<span class="opt">))</span>
              i <span class="opt">(+</span> i <span class="opt">(</span><span class="kwa">-</span> <span class="opt">(</span><span class="kwa">the</span> fixnum <span class="opt">(</span><span class="kwa">car</span> pair<span class="opt">))</span> j<span class="opt">))</span>
              <span class="opt">(</span><span class="kwa">subseq</span> result-string i<span class="opt">)</span> replacement
              j <span class="opt">(</span><span class="kwa">cdr</span> pair<span class="opt">)</span>
              i <span class="opt">(+</span> i len<span class="opt">))</span>
     finally <span class="opt">(</span><span class="kwa">if</span> <span class="opt">(</span><span class="kwa">or</span> <span class="opt">(</span><span class="kwa">minusp</span> match-end<span class="opt">) (&lt;=</span> match-length match-end<span class="opt">))</span>
                 <span class="opt">(</span><span class="kwa">setf</span> <span class="opt">(</span><span class="kwa">subseq</span> result-string i <span class="opt">) (</span><span class="kwa">subseq</span> target-string j<span class="opt">))))</span>
  nil<span class="opt">)</span>

<span class="opt">#+</span>sb-thread
<span class="opt">(</span><span class="kwa">defun</span> <span class="kwb">parts</span>
    <span class="opt">(</span><span class="kwa">parts-num</span> len
     <span class="opt">&amp;</span>aux
     <span class="opt">(</span><span class="kwa">ranges</span> <span class="opt">(</span><span class="kwa">loop</span> with <span class="opt">(</span><span class="kwa">step</span> rest<span class="opt">)</span> of-type fixnum <span class="opt">=  (</span><span class="kwa">multiple-value-list</span> <span class="opt">(</span><span class="kwa">floor</span> len parts-num<span class="opt">))</span>
                with i of-type fixnum <span class="opt">=</span> <span class="num">0</span> while <span class="opt">(&lt;</span> i len<span class="opt">)</span>
                collect i into res of-type fixnum
                do <span class="opt">(</span><span class="kwa">incf</span> i step<span class="opt">)(</span><span class="kwa">if</span> <span class="opt">(</span><span class="kwa">plusp</span> rest<span class="opt">) (</span><span class="kwa">progn</span> <span class="opt">(</span><span class="kwa">incf</span> i<span class="opt">) (</span><span class="kwa">decf</span> rest<span class="opt">)) )</span>
                finally <span class="opt">(</span><span class="kwa">return</span> <span class="opt">(</span><span class="kwa">append</span> res <span class="opt">(</span><span class="kwa">list</span> len<span class="opt">))))</span>
             <span class="opt">))</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">type</span> fixnum len parts-num<span class="opt">)</span>
           <span class="opt">(</span><span class="kwa">type</span> list ranges<span class="opt">))</span>
  <span class="opt">(</span><span class="kwa">mapcar</span> <span class="opt">#&apos;</span>cons ranges <span class="opt">(</span><span class="kwa">subseq</span> ranges <span class="num">1</span><span class="opt">)))</span>

<span class="opt">(</span><span class="kwa">defun</span> <span class="kwb">replace-all</span>
    <span class="opt">(</span><span class="kwa">regexp</span> replacement target-string
     <span class="opt">&amp;</span>aux <span class="opt">(</span><span class="kwa">rmatch</span> <span class="opt">&apos;()) (</span><span class="kwa">match</span> <span class="opt">&apos;())</span>
     <span class="opt">(</span><span class="kwa">result-string</span> <span class="opt">(</span><span class="kwa">make-string</span> <span class="num">0</span> <span class="opt">:</span>element-type <span class="opt">&apos;</span>base-char<span class="opt">)))</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">type</span> simple-base-string result-string target-string<span class="opt">)</span>
           <span class="opt">(</span><span class="kwa">type</span> vector replacement<span class="opt">))</span>
  <span class="opt">(</span><span class="kwa">cl-ppcre</span><span class="opt">:</span>do-scans
      <span class="opt">(</span><span class="kwa">match-start</span> match-end reg-starts reg-ends regexp target-string nil<span class="opt">)</span>
    <span class="opt">(</span><span class="kwa">push</span> <span class="opt">(</span><span class="kwa">cons</span> match-start match-end<span class="opt">)</span> rmatch<span class="opt">))</span>
  <span class="opt">(</span><span class="kwa">if</span> rmatch
      <span class="opt">(</span><span class="kwa">progn</span>
        <span class="opt">(</span><span class="kwa">setf</span> match <span class="opt">(</span><span class="kwa">reverse</span> rmatch<span class="opt">)</span>
              result-string <span class="opt">(</span><span class="kwa">make-string</span>
                             <span class="opt">(+ (</span><span class="kwa">-</span> <span class="opt">(</span><span class="kwa">length</span> target-string<span class="opt">)</span>
                                   <span class="opt">(</span><span class="kwa">length-to-replace</span> match<span class="opt">))</span>
                                <span class="opt">(</span><span class="kwa">the</span> fixnum <span class="opt">(* (</span><span class="kwa">length</span> replacement<span class="opt">)</span>
                                               <span class="opt">(</span><span class="kwa">length</span> match<span class="opt">)))) :</span>element-type <span class="opt">&apos;</span>base-char<span class="opt">))</span>
        <span class="opt">#</span>-sb-thread
        <span class="opt">(</span><span class="kwa">replace-aux</span> match replacement target-string result-string<span class="opt">)</span>
        <span class="opt">#+</span>sb-thread
        <span class="opt">(</span><span class="kwa">mapcar</span> <span class="opt">#&apos;</span>join-thread
                <span class="opt">(</span><span class="kwa">loop</span> with len of-type fixnum <span class="opt">= (</span><span class="kwa">length</span> match<span class="opt">)</span>
				   with parts-list  <span class="opt">= (</span><span class="kwa">parts</span> <span class="opt">+</span>cpu-count<span class="opt">+</span> len<span class="opt">)</span>
                   with current of-type fixnum <span class="opt">=</span> <span class="num">0</span>
                   repeat <span class="opt">+</span>cpu-count<span class="opt">+</span>
                   collect
					 <span class="opt">(</span><span class="kwa">bg</span> <span class="opt">(</span><span class="kwa">let</span> <span class="opt">(</span><span class="kwa">range</span><span class="opt">)</span>
                           <span class="opt">(</span><span class="kwa">with-mutex</span> <span class="opt">(*</span>mutex<span class="opt">*)</span>
                             <span class="opt">(</span><span class="kwa">setf</span> range <span class="opt">(</span><span class="kwa">nth</span> current parts-list<span class="opt">))</span>
                             <span class="opt">(</span><span class="kwa">incf</span> current<span class="opt">))</span>
                           <span class="opt">(</span><span class="kwa">replace-aux</span> match replacement target-string result-string
                                        <span class="opt">:</span>match-begin <span class="opt">(</span><span class="kwa">car</span> range<span class="opt">) :</span>match-end <span class="opt">(</span><span class="kwa">cdr</span> range<span class="opt">)</span>
                                        <span class="opt">:</span>match-length len<span class="opt">)))))</span>
        result-string<span class="opt">)</span>
      target-string<span class="opt">))</span>

<span class="opt">(</span><span class="kwa">defun</span> <span class="kwb">main</span> <span class="opt">(&amp;</span>optional <span class="opt">(</span><span class="kwa">stream</span> <span class="opt">*</span>standard-input<span class="opt">*)</span>
             <span class="opt">&amp;</span>aux <span class="opt">(</span><span class="kwa">sequence</span> <span class="opt">(</span><span class="kwa">read-all</span> stream<span class="opt">))</span>
             <span class="opt">(</span><span class="kwa">size</span> <span class="opt">(</span><span class="kwa">length</span> sequence<span class="opt">)))</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">type</span> simple-base-string sequence<span class="opt">))</span>
  <span class="opt">(</span><span class="kwa">setf</span> sequence <span class="opt">(</span><span class="kwa">replace-all</span> <span class="str">&quot;&gt;[^</span><span class="esc">\\</span><span class="str">n]*</span><span class="esc">\\</span><span class="str">n|</span><span class="esc">\\</span><span class="str">n&quot;</span> <span class="str">&quot;&quot;</span> sequence<span class="opt">))</span>

  <span class="opt">#</span>-sb-thread
  <span class="opt">(</span><span class="kwa">progn</span>
    <span class="opt">(</span><span class="kwa">loop</span> for regex in <span class="opt">+</span>regex-list<span class="opt">+</span> do
         <span class="opt">(</span><span class="kwa">format</span> t <span class="str">&quot;~a ~a~%&quot;</span> regex
                 <span class="opt">(/ (</span><span class="kwa">length</span>
                     <span class="opt">(</span><span class="kwa">the</span> list
                       <span class="opt">(</span><span class="kwa">cl-ppcre</span><span class="opt">:</span>all-matches regex sequence<span class="opt">)))</span> <span class="num">2</span><span class="opt">)))</span>
    <span class="opt">(</span><span class="kwa">format</span> t <span class="str">&quot;~%~a~%~a~%&quot;</span> size <span class="opt">(</span><span class="kwa">length</span> sequence<span class="opt">))</span>
    <span class="opt">(</span><span class="kwa">loop</span> for pair in <span class="opt">+</span>alternatives<span class="opt">+</span> do
         <span class="opt">(</span><span class="kwa">setf</span> sequence <span class="opt">(</span><span class="kwa">replace-all</span>  <span class="opt">(</span><span class="kwa">car</span> pair<span class="opt">) (</span><span class="kwa">cadr</span> pair<span class="opt">)</span> sequence <span class="opt">)))</span>
    <span class="opt">(</span><span class="kwa">format</span> t <span class="str">&quot;~a~%&quot;</span> <span class="opt">(</span><span class="kwa">length</span> sequence<span class="opt">)))</span>
  <span class="opt">#+</span>sb-thread
  <span class="opt">(</span><span class="kwa">let</span><span class="opt">* ((</span><span class="kwa">len</span> <span class="opt">(</span><span class="kwa">length</span> <span class="opt">+</span>regex-list<span class="opt">+))</span>
         <span class="opt">(</span><span class="kwa">result</span> <span class="opt">(</span><span class="kwa">make-list</span> <span class="opt">(</span><span class="kwa">1</span><span class="opt">+</span> len<span class="opt">))))</span>
    <span class="opt">(</span><span class="kwa">join-all</span>
	 <span class="opt">(</span><span class="kwa">loop</span> with idx of-type fixnum <span class="opt">=</span> <span class="num">0</span>
		repeat len
		collect
          <span class="opt">(</span><span class="kwa">bg</span> <span class="opt">(</span><span class="kwa">let</span> <span class="opt">(</span><span class="kwa">reg</span> cur<span class="opt">)</span>
                <span class="opt">(</span><span class="kwa">with-mutex</span> <span class="opt">(*</span>aux-mutex<span class="opt">*)</span>
                  <span class="opt">(</span><span class="kwa">setf</span> cur idx reg <span class="opt">(</span><span class="kwa">nth</span> cur <span class="opt">+</span>regex-list<span class="opt">+))</span>
                  <span class="opt">(</span><span class="kwa">incf</span> idx<span class="opt">))</span>
              <span class="opt">(</span><span class="kwa">setf</span> <span class="opt">(</span><span class="kwa">nth</span> cur result<span class="opt">)</span>
                    <span class="opt">(</span><span class="kwa">format</span> nil <span class="str">&quot;~a ~a&quot;</span> reg
                            <span class="opt">(/ (</span><span class="kwa">length</span>
                                <span class="opt">(</span><span class="kwa">the</span> list
                                  <span class="opt">(</span><span class="kwa">cl-ppcre</span><span class="opt">:</span>all-matches reg sequence<span class="opt">)))</span> <span class="num">2</span><span class="opt">))))))</span>
	 <span class="opt">(</span><span class="kwa">bg</span> <span class="opt">(</span><span class="kwa">loop</span> with seq <span class="opt">= (</span><span class="kwa">copy-seq</span> sequence<span class="opt">)</span>
            for pair in <span class="opt">+</span>alternatives<span class="opt">+</span> do
              <span class="opt">(</span><span class="kwa">setf</span> seq <span class="opt">(</span><span class="kwa">replace-all</span>  <span class="opt">(</span><span class="kwa">car</span> pair<span class="opt">) (</span><span class="kwa">cadr</span> pair<span class="opt">)</span> seq <span class="opt">))</span>
            finally <span class="opt">(</span><span class="kwa">setf</span> <span class="opt">(</span><span class="kwa">nth</span> len result<span class="opt">)</span>
                          <span class="opt">(</span><span class="kwa">format</span> nil <span class="str">&quot;~%~a~%~a~%~a&quot;</span> size <span class="opt">(</span><span class="kwa">length</span> sequence<span class="opt">) (</span><span class="kwa">length</span> seq<span class="opt">))))))</span>
    <span class="opt">(</span><span class="kwa">format</span> t <span class="str">&quot;~{~a~%~}&quot;</span> result<span class="opt">))</span>
  <span class="opt">)</span>
    </pre>
  </section>
  <section>
    <div>
      <h2 id="log">notes, command-line, and program output</h2>
    </div>
    <pre>
NOTES:
64-bit Ubuntu quad core
SBCL 2.0.10


Wed, 28 Oct 2020 21:23:45 GMT

MAKE:
cp: 'regexredux.sbcl-4.sbcl' and './regexredux.sbcl-4.sbcl' are the same file
SBCL built with: /usr/local/bin/sbcl --userinit /dev/null --batch --eval '(load &quot;regexredux.sbcl-4.sbcl_compile&quot;)'
### START regexredux.sbcl-4.sbcl_compile
(handler-bind ((sb-ext:defconstant-uneql      (lambda (c) (abort c))))      (require :sb-concurrency)      (load (compile-file &quot;regexredux.sbcl-4.sbcl&quot; ))) (save-lisp-and-die &quot;sbcl.core&quot; :purify t)
### END regexredux.sbcl-4.sbcl_compile

; compiling file &quot;/home/dunham/all-benchmarksgame/2000-benchmarksgame/bench/regexredux/regexredux.sbcl-4.sbcl&quot; (written 28 SEP 2020 04:58:03 PM):
; processing (REQUIRE :ASDF)
; processing (REQUIRE :CL-PPCRE); 
; caught WARNING:
;   System definition file #P&quot;/home/dunham/common-lisp/cl-ppcre/cl-ppcre.asd&quot; contains definition for system &quot;cl-ppcre-test&quot;. Please only define &quot;cl-ppcre&quot; and secondary systems with a name starting with &quot;cl-ppcre/&quot; (e.g. &quot;cl-ppcre/test&quot;) in that file.

; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/packages.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; wrote /home/dunham/.cache/common-lisp/sbcl-2.0.10-linux-x64/home/dunham/common-lisp/cl-ppcre/packages-tmpGHU3ALSV.fasl
; compilation finished in 0:00:00.008
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/specials.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; wrote /home/dunham/.cache/common-lisp/sbcl-2.0.10-linux-x64/home/dunham/common-lisp/cl-ppcre/specials-tmpAAURSO1.fasl
; compilation finished in 0:00:00.012
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/util.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/util.lisp
; in: DEFUN STRING-LIST-TO-SIMPLE-STRING
;     (REPLACE CL-PPCRE::RESULT-STRING STRING :START1 CL-PPCRE::CURR-POS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a STRING, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a STRING, not a SIMPLE-BASE-STRING.

; in: DEFUN COMPLEMENT*
;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; --&gt; SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function


; wrote /home/dunham/.cache/common-lisp/sbcl-2.0.10-linux-x64/home/dunham/common-lisp/cl-ppcre/util-tmp5GEXGEG5.fasl
; compilation finished in 0:00:00.028
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/errors.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; wrote /home/dunham/.cache/common-lisp/sbcl-2.0.10-linux-x64/home/dunham/common-lisp/cl-ppcre/errors-tmpAR3FSGEY.fasl
; compilation finished in 0:00:00.008
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/charset.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/charset.lisp
; in: DEFUN MIX
;     (+ CL-PPCRE::CODE CL-PPCRE::HASH)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; in: DEFUN COMPUTE-INDEX
;     (LENGTH VECTOR)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (MOD CL-PPCRE::HASH (1- (LENGTH VECTOR)))
; --&gt; NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FLOOR 
; --&gt; MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==&gt;
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.

;     (1+ (MOD CL-PPCRE::HASH (1- (LENGTH VECTOR))))
; ==&gt;
;   (+ (MOD CL-PPCRE::HASH (1- (LENGTH VECTOR))) 1)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a (OR
;                            (RATIONAL (-4611686018427387899)
;                                      (4611686018427387899))
;                            DOUBLE-FLOAT SINGLE-FLOAT), not a RATIONAL.

;     (MOD CL-PPCRE::HASH (1- (LENGTH VECTOR)))
; --&gt; NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FLOOR 
; --&gt; MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF NOT IF ZEROP 
; ==&gt;
;   (= REM 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR
;                            (RATIONAL (-4611686018427387899)
;                                      (4611686018427387899))
;                            DOUBLE-FLOAT SINGLE-FLOAT), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --&gt; NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FLOOR 
; --&gt; MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF IF PLUSP 
; ==&gt;
;   (&gt; NUMBER 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --&gt; NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FLOOR 
; --&gt; MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF IF MINUSP 
; ==&gt;
;   (&lt; NUMBER 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --&gt; NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FLOOR 
; --&gt; MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF IF PLUSP 
; ==&gt;
;   (&gt; NUMBER 0)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --&gt; NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FLOOR 
; --&gt; MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF VALUES 
; ==&gt;
;   (+ REM SB-C::DIVISOR)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR
;                                (RATIONAL (-4611686018427387899)
;                                          (4611686018427387899))
;                                DOUBLE-FLOAT SINGLE-FLOAT), not a FIXNUM.
;       The result is a (VALUES
;                        (OR SINGLE-FLOAT DOUBLE-FLOAT
;                            (RATIONAL (-4611686018427387900)
;                                      (9223372036854775798)))
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a (OR
;                                (RATIONAL (-4611686018427387899)
;                                          (4611686018427387899))
;                                DOUBLE-FLOAT SINGLE-FLOAT), not a (SIGNED-BYTE
;                                                                   64).
;       The result is a (VALUES
;                        (OR SINGLE-FLOAT DOUBLE-FLOAT
;                            (RATIONAL (-4611686018427387900)
;                                      (9223372036854775798)))
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL MULTIPLE-VALUE-BIND LET 
; --&gt; UNLESS IF OR LET TYPEP LET SB-C::%TYPEP-WRAPPER AND IF LOCALLY AND IF 
; ==&gt;
;   (&gt; (TRULY-THE RATIONAL #:OBJECT18) -4611686018427387899)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a (RATIONAL (-4611686018427387900)
;                                         (9223372036854775798)), not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (RATIONAL (-4611686018427387900)
;                                         (9223372036854775798)), not a FIXNUM.
;       etc.

; --&gt; NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL MULTIPLE-VALUE-BIND LET 
; --&gt; UNLESS IF OR LET TYPEP LET SB-C::%TYPEP-WRAPPER AND IF LOCALLY AND IF &lt; 
; --&gt; IF 
; ==&gt;
;   (&lt; (TRULY-THE RATIONAL #:OBJECT18) 4611686018427387899)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a (RATIONAL (-4611686018427387899)
;                                         (9223372036854775798)), not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (RATIONAL (-4611686018427387899)
;                                         (9223372036854775798)), not a FIXNUM.
;       etc.

;     (1+ (MOD CL-PPCRE::HASH (1- (LENGTH VECTOR))))
; ==&gt;
;   (+ (MOD CL-PPCRE::HASH (1- (LENGTH VECTOR))) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR
;                                (RATIONAL (-4611686018427387899)
;                                          (4611686018427387899))
;                                DOUBLE-FLOAT SINGLE-FLOAT), not a FIXNUM.
;       The result is a (VALUES
;                        (OR SINGLE-FLOAT DOUBLE-FLOAT
;                            (RATIONAL (-4611686018427387898)
;                                      (4611686018427387900)))
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR
;                                (RATIONAL (-4611686018427387899)
;                                          (4611686018427387899))
;                                DOUBLE-FLOAT SINGLE-FLOAT), not a FIXNUM.
;       The result is a (VALUES
;                        (OR SINGLE-FLOAT DOUBLE-FLOAT
;                            (RATIONAL (-4611686018427387898)
;                                      (4611686018427387900)))
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; in: DEFUN %ADD-TO-CHARSET/EXPAND
;     (* 2 CL-PPCRE::NEW-SIZE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
; 
; note: unable to
;   associate */(* /) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (&gt;= CL-PPCRE::NEW-SIZE 371370)
; --&gt; OR LET &gt; IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --&gt; OR LET IF = IF 
; ==&gt;
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR (DOUBLE-FLOAT * 371370.0d0)
;                               (SINGLE-FLOAT * 371370.0)
;                               (RATIONAL * 371370)), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (* 2 CL-PPCRE::NEW-SIZE)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (&gt;= CL-PPCRE::NEW-SIZE 371370)
; --&gt; OR LET &gt; IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (LET* ((CL-PPCRE::OLD-VECTOR (CL-PPCRE::CHARSET-VECTOR SET))
;            (CL-PPCRE::NEW-SIZE (* 2 (LENGTH CL-PPCRE::OLD-VECTOR))))
;       (TAGBODY
;        :RETRY
;         (MULTIPLE-VALUE-BIND (CL-PPCRE::NEW-DEPTH CL-PPCRE::NEW-VECTOR)
;             (IF (&gt;= CL-PPCRE::NEW-SIZE 371370)
;                 (VALUES 0 #)
;                 (VALUES CL-PPCRE::+PROBE-DEPTH+ #))
;           (SETF # CL-PPCRE::NEW-DEPTH
;                 # CL-PPCRE::NEW-VECTOR)
;           (FLET (#)
;             (CL-PPCRE::TRY-ADD CHAR)
;             (DOTIMES # #))))
;       (INCF (CL-PPCRE::CHARSET-COUNT SET))
;       T)
; 
; note: doing signed word to integer coercion (cost 20) to NEW-SIZE

; in: DEFUN MAP-CHARSET
;     (ZEROP (DECF CL-PPCRE::N))
; ==&gt;
;   (= (DECF CL-PPCRE::N) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

;     (DECF CL-PPCRE::N)
; --&gt; SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==&gt;
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; in: DEFUN CREATE-CHARSET-FROM-TEST-FUNCTION
;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; --&gt; SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (LOOP CL-PPCRE::WITH CL-PPCRE::CHARSET = (CL-PPCRE::MAKE-CHARSET)
;           CL-PPCRE::FOR CL-PPCRE::CODE CL-PPCRE::FROM CL-PPCRE::START CL-PPCRE::BELOW
;           CL-PPCRE::END
;           CL-PPCRE::FOR ...)
; --&gt; BLOCK LET LET LET TAGBODY WHEN IF &gt;= OR LET &gt; IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

; --&gt; BLOCK LET LET LET TAGBODY WHEN IF &gt;= OR LET IF = IF 
; ==&gt;
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --&gt; BLOCK LET LET LET TAGBODY WHEN IF &gt;= OR LET &gt; IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --&gt; BLOCK LET LET LET TAGBODY WHEN IF &gt;= OR LET IF = IF 
; ==&gt;
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.


; wrote /home/dunham/.cache/common-lisp/sbcl-2.0.10-linux-x64/home/dunham/common-lisp/cl-ppcre/charset-tmpJAIDFZTC.fasl
; compilation finished in 0:00:00.064
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/charmap.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/charmap.lisp
; in: DEFUN MAKE-CHARMAP
;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; --&gt; SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

; in: DEFUN CREATE-CHARMAP-FROM-TEST-FUNCTION
;     (LOOP CL-PPCRE::FOR CL-PPCRE::CODE CL-PPCRE::FROM (1-
;                                                        CL-PPCRE::END) CL-PPCRE::DOWNTO CL-PPCRE::START
;           CL-PPCRE::FOR CHAR = (CODE-CHAR CL-PPCRE::CODE)
;           CL-PPCRE::UNTIL ...)
; --&gt; BLOCK LET LET TAGBODY WHEN IF 
; ==&gt;
;   (&lt; CL-PPCRE::CODE #:LOOP-LIMIT-24)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; --&gt; SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (LOOP CL-PPCRE::FOR CL-PPCRE::CODE CL-PPCRE::FROM CL-PPCRE::START CL-PPCRE::BELOW
;           CL-PPCRE::END
;           CL-PPCRE::FOR CHAR = (CODE-CHAR CL-PPCRE::CODE)
;           CL-PPCRE::UNTIL ...)
; --&gt; BLOCK LET LET TAGBODY WHEN IF &gt;= OR LET &gt; IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

; --&gt; BLOCK LET LET TAGBODY WHEN IF &gt;= OR LET IF = IF 
; ==&gt;
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --&gt; BLOCK LET LET TAGBODY WHEN IF &gt;= OR LET &gt; IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --&gt; BLOCK LET LET TAGBODY WHEN IF &gt;= OR LET IF = IF 
; ==&gt;
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (1- CL-PPCRE::END)
; ==&gt;
;   (- CL-PPCRE::END 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (LOOP CL-PPCRE::FOR CL-PPCRE::CODE CL-PPCRE::FROM (1-
;                                                        CL-PPCRE::END) CL-PPCRE::DOWNTO CL-PPCRE::START
;           CL-PPCRE::FOR CHAR = (CODE-CHAR CL-PPCRE::CODE)
;           CL-PPCRE::UNTIL ...)
; --&gt; BLOCK LET LET TAGBODY WHEN IF 
; ==&gt;
;   (&lt; CL-PPCRE::CODE #:LOOP-LIMIT-24)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.


; wrote /home/dunham/.cache/common-lisp/sbcl-2.0.10-linux-x64/home/dunham/common-lisp/cl-ppcre/charmap-tmp8V3J6PE9.fasl
; compilation finished in 0:00:00.044
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/chartest.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/chartest.lisp
; in: DEFUN CREATE-HASH-TABLE-FROM-TEST-FUNCTION
;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; --&gt; SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (LOOP CL-PPCRE::WITH HASH-TABLE = (MAKE-HASH-TABLE)
;           CL-PPCRE::FOR CL-PPCRE::CODE CL-PPCRE::FROM CL-PPCRE::START CL-PPCRE::BELOW
;           CL-PPCRE::END
;           CL-PPCRE::FOR ...)
; --&gt; BLOCK LET LET LET TAGBODY WHEN IF &gt;= OR LET &gt; IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

; --&gt; BLOCK LET LET LET TAGBODY WHEN IF &gt;= OR LET IF = IF 
; ==&gt;
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --&gt; BLOCK LET LET LET TAGBODY WHEN IF &gt;= OR LET &gt; IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --&gt; BLOCK LET LET LET TAGBODY WHEN IF &gt;= OR LET IF = IF 
; ==&gt;
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; in: DEFUN CREATE-OPTIMIZED-TEST-FUNCTION
;     (CEILING (- CL-PPCRE::END CL-PPCRE::START) 2)
; --&gt; MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==&gt;
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   convert division by 2^k to shift
; due to type uncertainty:
;   The first argument is a REAL, not a INTEGER.
; 
; note: unable to
;   convert integer division to multiplication
; due to type uncertainty:
;   The first argument is a REAL, not a (UNSIGNED-BYTE 64).

; --&gt; MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF NOT IF ZEROP 
; ==&gt;
;   (= REM 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR (RATIONAL (-2) (2)) DOUBLE-FLOAT
;                               SINGLE-FLOAT), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --&gt; MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF IF PLUSP 
; ==&gt;
;   (&gt; NUMBER 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --&gt; MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==&gt;
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   convert division by 2^k to shift
; due to type uncertainty:
;   The first argument is a REAL, not a INTEGER.
; 
; note: unable to
;   convert integer division to multiplication
; due to type uncertainty:
;   The first argument is a REAL, not a (UNSIGNED-BYTE 64).

; --&gt; MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF NOT IF ZEROP 
; ==&gt;
;   (= REM 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR (RATIONAL (-2) (2)) DOUBLE-FLOAT
;                               SINGLE-FLOAT), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --&gt; MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF IF PLUSP 
; ==&gt;
;   (&gt; NUMBER 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

;     (CEILING (- CL-PPCRE::END CL-PPCRE::START) 2)
; --&gt; MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF IF PLUSP 
; ==&gt;
;   (&gt; NUMBER 0)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --&gt; MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF VALUES 
; ==&gt;
;   (+ SB-C::TRU 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (&lt;= (HASH-TABLE-COUNT HASH-TABLE)
;         (CEILING (- CL-PPCRE::END CL-PPCRE::START) 2))
; --&gt; IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a INTEGER, not a FIXNUM.

;     (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

;     (CEILING (- CL-PPCRE::END CL-PPCRE::START) 2)
; --&gt; MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF IF PLUSP 
; ==&gt;
;   (&gt; NUMBER 0)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --&gt; MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF VALUES 
; ==&gt;
;   (+ SB-C::TRU 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (&lt;= (CL-PPCRE::CHARSET-COUNT CL-PPCRE::CHARSET)
;         (CEILING (- CL-PPCRE::END CL-PPCRE::START) 2))
; --&gt; IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a INTEGER, not a FIXNUM.


; wrote /home/dunham/.cache/common-lisp/sbcl-2.0.10-linux-x64/home/dunham/common-lisp/cl-ppcre/chartest-tmp9V47YWQF.fasl
; compilation finished in 0:00:00.016
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/lexer.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/lexer.lisp
; in: DEFUN NEXT-CHAR
;     (- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER) 2)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

; in: DEFUN GET-NUMBER
;     (IF (&lt; CL-PPCRE::END-POS CL-PPCRE::LEXER-LEN)
;         CL-PPCRE::END-POS
;         CL-PPCRE::LEXER-LEN)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN MAKE-CHAR-FROM-CODE
;     (CL-PPCRE::SIGNAL-SYNTAX-ERROR* CL-PPCRE::ERROR-POS
;                                     &quot;No character for hex-code ~X.&quot; NUMBER)
; --&gt; ERROR 
; ==&gt;
;   CL-PPCRE::ERROR-POS
; 
; note: deleting unreachable code

; in: DEFUN UNESCAPE-CHAR
;     (CL-PPCRE::MAKE-CHAR-FROM-CODE NUMBER CL-PPCRE::ERROR-POS)
; --&gt; BLOCK LET OR LET IF CL-PPCRE::SIGNAL-SYNTAX-ERROR* ERROR LIST CONS 
; ==&gt;
;   NUMBER
; 
; note: deleting unreachable code
; 
; note: deleting unreachable code

;     (CHAR-UPCASE CL-PPCRE::NEXT-CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.


; wrote /home/dunham/.cache/common-lisp/sbcl-2.0.10-linux-x64/home/dunham/common-lisp/cl-ppcre/lexer-tmp9BN22RMA.fasl
; compilation finished in 0:00:00.128
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/parser.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/parser.lisp
; in: DEFUN GROUP
;     (+ CL-PPCRE::OPEN-PAREN-POS 2)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic


; wrote /home/dunham/.cache/common-lisp/sbcl-2.0.10-linux-x64/home/dunham/common-lisp/cl-ppcre/parser-tmp1CXFJSK9.fasl
; compilation finished in 0:00:00.020
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/regex-class.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/regex-class.lisp
; in: DEFMETHOD INITIALIZE-INSTANCE :AFTER (STR)
;     (COERCE CL-PPCRE::STR-SLOT 'SIMPLE-STRING)
; --&gt; THE IF REPLACE MAKE-ARRAY 
; ==&gt;
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR CONS NULL
;                               (AND (NOT (SIMPLE-ARRAY CHARACTER (*)))
;                                    (NOT (SIMPLE-ARRAY NIL (*)))
;                                    (NOT SIMPLE-BASE-STRING) VECTOR)
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

;     (LENGTH (CL-PPCRE::STR CL-PPCRE::STR))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.


; wrote /home/dunham/.cache/common-lisp/sbcl-2.0.10-linux-x64/home/dunham/common-lisp/cl-ppcre/regex-class-tmpX4BRKI0R.fasl
; compilation finished in 0:00:00.012
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/regex-class-util.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/regex-class-util.lisp
; in: DEFMETHOD CASE-MODE (STR T)
;     (ZEROP (CL-PPCRE::LEN CL-PPCRE::STR))
; ==&gt;
;   (= (CL-PPCRE::LEN CL-PPCRE::STR) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

; in: DEFMETHOD EVERYTHINGP (SEQ)
;     (LENGTH CL-PPCRE::CLEANED-ELEMENTS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

; in: DEFMETHOD EVERYTHINGP (ALTERNATION)
;     (AND (= 1 (LENGTH CL-PPCRE::CHOICES))
;          (CL-PPCRE::EVERYTHINGP (FIRST CL-PPCRE::CHOICES)))
; --&gt; IF = 
; ==&gt;
;   (LENGTH
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::CHOICES)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::CHOICES)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; in: DEFMETHOD EVERYTHINGP (REPETITION)
;     (AND CL-PPCRE::MAXIMUM (= 1 CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM)
;          (CL-PPCRE::EVERYTHINGP CL-PPCRE::REGEX))
; --&gt; IF IF = 
; --&gt; (LAMBDA (#:G5 #:G4 #:G3) (DECLARE (TYPE NUMBER #:G5 #:G4 #:G3)) (IF (= #:G5 #:G4) (IF (= #:G4 #:G3) T NIL) NIL)) 
; --&gt; SB-C::%FUNCALL IF 
; ==&gt;
;   (= #:G5 #:G4)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

; --&gt; IF IF = 
; --&gt; (LAMBDA (#:G5 #:G4 #:G3) (DECLARE (TYPE NUMBER #:G5 #:G4 #:G3)) (IF (= #:G5 #:G4) (IF (= #:G4 #:G3) T NIL) NIL)) 
; --&gt; SB-C::%FUNCALL IF IF 
; ==&gt;
;   (= #:G4 #:G3)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR (DOUBLE-FLOAT 1.0d0 1.0d0) (SINGLE-FLOAT 1.0 1.0)
;                               (INTEGER 1 1)
;                               (COMPLEX (DOUBLE-FLOAT 1.0d0 1.0d0))
;                               (COMPLEX (SINGLE-FLOAT 1.0 1.0))
;                               (COMPLEX (INTEGER 1 1))), not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR (DOUBLE-FLOAT 1.0d0 1.0d0) (SINGLE-FLOAT 1.0 1.0)
;                               (INTEGER 1 1)
;                               (COMPLEX (DOUBLE-FLOAT 1.0d0 1.0d0))
;                               (COMPLEX (SINGLE-FLOAT 1.0 1.0))
;                               (COMPLEX (INTEGER 1 1))), not a (OR
;                                                                (COMPLEX
;                                                                 SINGLE-FLOAT)
;                                                                (COMPLEX
;                                                                 DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (OR (DOUBLE-FLOAT 1.0d0 1.0d0)
;                                   (SINGLE-FLOAT 1.0 1.0) (INTEGER 1 1)
;                                   (COMPLEX (DOUBLE-FLOAT 1.0d0 1.0d0))
;                                   (COMPLEX (SINGLE-FLOAT 1.0 1.0))
;                                   (COMPLEX (INTEGER 1 1))), not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (OR (DOUBLE-FLOAT 1.0d0 1.0d0)
;                                   (SINGLE-FLOAT 1.0 1.0) (INTEGER 1 1)
;                                   (COMPLEX (DOUBLE-FLOAT 1.0d0 1.0d0))
;                                   (COMPLEX (SINGLE-FLOAT 1.0 1.0))
;                                   (COMPLEX (INTEGER 1 1))), not a (COMPLEX
;                                                                    DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; in: DEFMETHOD REGEX-LENGTH (SEQ)
;     (LOOP CL-PPCRE::FOR CL-PPCRE::SUB-REGEX CL-PPCRE::IN (CL-PPCRE::ELEMENTS
;                                                           CL-PPCRE::SEQ)
;           CL-PPCRE::FOR CL-PPCRE::LEN = (CL-PPCRE::REGEX-LENGTH
;                                          CL-PPCRE::SUB-REGEX)
;           IF (NOT CL-PPCRE::LEN)
;           DO ...)
; --&gt; BLOCK LET LET SB-LOOP::WITH-SUM-COUNT LET TAGBODY SETQ THE 
; ==&gt;
;   (+ #:LOOP-SUM-5 CL-PPCRE::LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a (NOT NULL), not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; in: DEFMETHOD REGEX-LENGTH (ALTERNATION)
;     (/= CL-PPCRE::LEN CL-PPCRE::OLD-LEN)
; --&gt; IF 
; ==&gt;
;   (= CL-PPCRE::LEN CL-PPCRE::OLD-LEN)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The second argument is a (NOT NULL), not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a (NOT NULL), not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; in: DEFMETHOD REGEX-LENGTH (BRANCH)
;     (EQL CL-PPCRE::THEN-LENGTH
;          (CL-PPCRE::REGEX-LENGTH (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)))
; 
; note: forced to do IF-EQL (cost 15)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a (NOT NULL), not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; in: DEFMETHOD REGEX-LENGTH (REPETITION)
;     (WITH-SLOTS (CL-PPCRE::LEN CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM)
;         CL-PPCRE::REPETITION
;       (IF (AND CL-PPCRE::LEN (EQL CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM))
;           (* CL-PPCRE::MINIMUM CL-PPCRE::LEN)
;           NIL))
; --&gt; LET SYMBOL-MACROLET IF 
; ==&gt;
;   (*
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MINIMUM)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MINIMUM))
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::LEN)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::LEN)))
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.

;     (AND CL-PPCRE::LEN (EQL CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM))
; --&gt; IF 
; ==&gt;
;   (EQL
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MINIMUM)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MINIMUM))
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MAXIMUM)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MAXIMUM)))
; 
; note: forced to do IF-EQL (cost 15)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (WITH-SLOTS (CL-PPCRE::LEN CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM)
;         CL-PPCRE::REPETITION
;       (IF (AND CL-PPCRE::LEN (EQL CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM))
;           (* CL-PPCRE::MINIMUM CL-PPCRE::LEN)
;           NIL))
; --&gt; LET SYMBOL-MACROLET IF 
; ==&gt;
;   (*
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MINIMUM)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MINIMUM))
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::LEN)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::LEN)))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES
;                                                         (COMPLEX SINGLE-FLOAT)
;                                                         &amp;REST T).
;       etc.

; in: DEFMETHOD REGEX-MIN-LENGTH (SEQ)
;     (LOOP CL-PPCRE::FOR CL-PPCRE::SUB-REGEX CL-PPCRE::IN (CL-PPCRE::ELEMENTS
;                                                           CL-PPCRE::SEQ)
;           CL-PPCRE::FOR CL-PPCRE::LEN = (CL-PPCRE::REGEX-MIN-LENGTH
;                                          CL-PPCRE::SUB-REGEX)
;           CL-PPCRE::SUM CL-PPCRE::LEN)
; --&gt; BLOCK LET LET SB-LOOP::WITH-SUM-COUNT LET TAGBODY SETQ THE 
; ==&gt;
;   (+ #:LOOP-SUM-5 CL-PPCRE::LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; in: DEFMETHOD REGEX-MIN-LENGTH (ALTERNATION)
;     (LOOP CL-PPCRE::FOR CL-PPCRE::SUB-REGEX CL-PPCRE::IN (CL-PPCRE::CHOICES
;                                                           CL-PPCRE::ALTERNATION)
;           CL-PPCRE::FOR CL-PPCRE::LEN = (CL-PPCRE::REGEX-MIN-LENGTH
;                                          CL-PPCRE::SUB-REGEX)
;           CL-PPCRE::MINIMIZE CL-PPCRE::LEN)
; --&gt; BLOCK LET LET SB-LOOP::WITH-MINIMAX-VALUE LET TAGBODY 
; --&gt; SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF &lt; IF 
; ==&gt;
;   (&lt; #:LOOP-MAXMIN-TEMP-9 #:LOOP-MAXMIN-8)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; in: DEFMETHOD REGEX-MIN-LENGTH (BRANCH)
;     (MIN (CL-PPCRE::REGEX-MIN-LENGTH (CL-PPCRE::THEN-REGEX CL-PPCRE::BRANCH))
;          (CL-PPCRE::REGEX-MIN-LENGTH (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)))
; --&gt; LET LET IF &lt;= OR LET &lt; IF 
; ==&gt;
;   (&lt; SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

; --&gt; LET LET IF &lt;= OR LET IF = IF 
; ==&gt;
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --&gt; LET LET IF &lt;= OR LET &lt; IF 
; ==&gt;
;   (&lt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --&gt; LET LET IF &lt;= OR LET IF = IF 
; ==&gt;
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; in: DEFMETHOD REGEX-MIN-LENGTH (REPETITION)
;     (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;        (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION))
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES
;                                                         (COMPLEX SINGLE-FLOAT)
;                                                         &amp;REST T).
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (ALTERNATION T)
;     (/= CL-PPCRE::CURR-OFFSET CL-PPCRE::OLD-OFFSET)
; --&gt; IF 
; ==&gt;
;   (= CL-PPCRE::CURR-OFFSET CL-PPCRE::OLD-OFFSET)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The second argument is a (NOT NULL), not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a (NOT NULL), not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (BRANCH T)
;     (EQL CL-PPCRE::THEN-OFFSET
;          (CL-PPCRE::COMPUTE-OFFSETS (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)
;           CL-PPCRE::START-POS))
; 
; note: forced to do IF-EQL (cost 15)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a (NOT NULL), not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (REPETITION T)
;     (WITH-SLOTS (CL-PPCRE::LEN CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM)
;         CL-PPCRE::REPETITION
;       (IF (AND CL-PPCRE::LEN (EQ CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM))
;           (+ CL-PPCRE::START-POS (* CL-PPCRE::MINIMUM CL-PPCRE::LEN))
;           NIL))
; --&gt; LET SYMBOL-MACROLET IF + 
; ==&gt;
;   (*
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MINIMUM)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MINIMUM))
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::LEN)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::LEN)))
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES
;                                                         (COMPLEX SINGLE-FLOAT)
;                                                         &amp;REST T).
;       etc.

; --&gt; LET SYMBOL-MACROLET IF 
; ==&gt;
;   (+ CL-PPCRE::START-POS
;      (*
;       (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MINIMUM)
;                               (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                            'CL-PPCRE::MINIMUM))
;       (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::LEN)
;                               (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                            'CL-PPCRE::LEN))))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (CHAR-CLASS T)
;     (1+ CL-PPCRE::START-POS)
; ==&gt;
;   (+ CL-PPCRE::START-POS 1)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (EVERYTHING T)
;     (1+ CL-PPCRE::START-POS)
; ==&gt;
;   (+ CL-PPCRE::START-POS 1)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (STR T)
;     (+ CL-PPCRE::START-POS (CL-PPCRE::LEN CL-PPCRE::STR))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; in: DEFMETHOD COMPUTE-OFFSETS (FILTER T)
;     (+ CL-PPCRE::START-POS CL-PPCRE::LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a (NOT NULL), not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.


; wrote /home/dunham/.cache/common-lisp/sbcl-2.0.10-linux-x64/home/dunham/common-lisp/cl-ppcre/regex-class-util-tmpQ371UGST.fasl
; compilation finished in 0:00:00.112
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/convert.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/convert.lisp
; in: DEFUN CONVERT-CHAR-CLASS-TO-TEST-FUNCTION
;     (FUNCALL CL-PPCRE::TEST-FUNCTION (CHAR-DOWNCASE CHAR))
; --&gt; SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (CHAR-DOWNCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION (CHAR-UPCASE CHAR))
; --&gt; SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (CHAR-UPCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION (CHAR-DOWNCASE CHAR))
; --&gt; SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (CHAR-DOWNCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION (CHAR-UPCASE CHAR))
; --&gt; SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (CHAR-UPCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; --&gt; SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (CHAR-DOWNCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (CHAR-UPCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CL-PPCRE::CHAR-DOWN)
; --&gt; SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CL-PPCRE::CHAR-UP)
; --&gt; SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (CHAR-DOWNCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (CHAR-UPCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CL-PPCRE::CHAR-DOWN)
; --&gt; SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CL-PPCRE::CHAR-UP)
; --&gt; SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

; in: DEFUN MAYBE-SPLIT-REPETITION
;     (- CL-PPCRE::MAXIMUM CL-PPCRE::MINIMUM)
; 
; note: doing signed word to integer coercion (cost 20)

; in: DEFUN MAYBE-ACCUMULATE
;     (SETF (SUBSEQ (SLOT-VALUE CL-PPCRE::STARTS-WITH 'CL-PPCRE::STR)
;                   (- (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH)
;                      (CL-PPCRE::LEN CL-PPCRE::STR)))
;             (CL-PPCRE::STR CL-PPCRE::STR)
;           (CL-PPCRE::SKIP CL-PPCRE::STR) T)
; --&gt; PROGN SETF LET* 
; ==&gt;
;   (REPLACE #:SEQUENCE #:NEW1 :START1 #:START :END1 NIL)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES SIMPLE-BASE-STRING
;                                                              &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY CHARACTER
;                                                        (*))
;                                                       &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        SINGLE-FLOAT (*))
;                                                       &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY DOUBLE-FLOAT (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY DOUBLE-FLOAT (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        DOUBLE-FLOAT (*))
;                                                       &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-BIT-VECTOR.
;   The second argument is a SEQUENCE, not a SIMPLE-BIT-VECTOR.
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES SIMPLE-BIT-VECTOR
;                                                              &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 2) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 2) (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 2) (*))
;                                                       &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 4) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 4) (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 4) (*))
;                                                       &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 7) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 7) (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 7) (*))
;                                                       &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 8) (*))
;                                                       &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 15) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 15)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 15) (*))
;                                                       &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 16) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 16)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 16) (*))
;                                                       &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 31) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 31)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 31) (*))
;                                                       &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 32) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 32)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 32) (*))
;                                                       &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 62) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 62)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 62) (*))
;                                                       &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 63) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 63)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 63) (*))
;                                                       &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 64) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 64)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 64) (*))
;                                                       &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 8) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 8) (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (SIGNED-BYTE 8) (*))
;                                                       &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 16) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 16) (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (SIGNED-BYTE 16) (*))
;                                                       &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 32) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 32) (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (SIGNED-BYTE 32) (*))
;                                                       &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY FIXNUM (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY FIXNUM (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY FIXNUM (*))
;                                                       &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 64) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 64) (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (SIGNED-BYTE 64) (*))
;                                                       &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX SINGLE-FLOAT)
;                                            (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX SINGLE-FLOAT)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (COMPLEX SINGLE-FLOAT)
;                                                        (*))
;                                                       &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX DOUBLE-FLOAT)
;                                            (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX DOUBLE-FLOAT)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (COMPLEX DOUBLE-FLOAT)
;                                                        (*))
;                                                       &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-VECTOR.
;   The second argument is a SEQUENCE, not a SIMPLE-VECTOR.
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES SIMPLE-VECTOR
;                                                              &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES SIMPLE-BASE-STRING
;                                                              &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES SEQUENCE &amp;OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY CHARACTER
;                                                        (*))
;                                                       &amp;REST T).

;     (+ (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH) (CL-PPCRE::LEN CL-PPCRE::STR))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

;     (- (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH) (CL-PPCRE::LEN CL-PPCRE::STR))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; in: DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ((EQL :BRANCH) T)
;     (LENGTH (CL-PPCRE::CHOICES CL-PPCRE::ALTERNATIONS))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; in: DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ((EQL :GREEDY-REPETITION) T)
;     (ZEROP LENGTH)
; --&gt; = IF 
; ==&gt;
;   (= LENGTH 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

; in: DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ((EQL :NAMED-REGISTER) T)
;     (COPY-SEQ (SECOND CL-PPCRE::PARSE-TREE))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

; in: DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ((EQL :BACK-REFERENCE) T)
;     (STRING= CL-PPCRE::NAME CL-PPCRE::BACKREF-NAME)
; ==&gt;
;   (SB-KERNEL:STRING=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.
;   The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                                (AND (NOT NULL) SYMBOL) CHARACTER), not a STRING.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SIMPLE-STRING.
;   The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                                (AND (NOT NULL) SYMBOL)
;                                CHARACTER), not a SIMPLE-STRING.

;     (COPY-SEQ CL-PPCRE::BACKREF-NAME)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

;     (- CL-PPCRE::REG-NUM CL-PPCRE::REG-INDEX)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a UNSIGNED-BYTE, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64)
;                                                                &amp;REST T).
;       etc.

;     (1- CL-PPCRE::BACKREF-NUMBER)
; ==&gt;
;   (- CL-PPCRE::BACKREF-NUMBER 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (LOOP CL-PPCRE::FOR CL-PPCRE::NAME CL-PPCRE::IN CL-PPCRE::REG-NAMES
;           CL-PPCRE::FOR CL-PPCRE::REG-INDEX CL-PPCRE::FROM 0
;           WHEN (STRING= CL-PPCRE::NAME CL-PPCRE::BACKREF-NAME)
;           CL-PPCRE::COLLECT ...)
; --&gt; BLOCK LET LET SB-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD LET* TAGBODY 
; --&gt; SB-LOOP::LOOP-DESETQ SETQ THE 1+ 
; ==&gt;
;   (+ CL-PPCRE::REG-INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &amp;OPTIONAL), not a (VALUES FIXNUM
;                                                                     &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &amp;OPTIONAL), not a (VALUES FIXNUM
;                                                                     &amp;REST T).
;       etc.

; in: DEFUN CONVERT
;     (COERCE (SLOT-VALUE CL-PPCRE::STARTS-WITH 'CL-PPCRE::STR) 'SIMPLE-STRING)
; --&gt; THE IF REPLACE MAKE-ARRAY 
; ==&gt;
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR CONS NULL
;                               (AND (NOT (SIMPLE-ARRAY CHARACTER (*)))
;                                    (NOT (SIMPLE-ARRAY NIL (*)))
;                                    (NOT SIMPLE-BASE-STRING) VECTOR)
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.


; wrote /home/dunham/.cache/common-lisp/sbcl-2.0.10-linux-x64/home/dunham/common-lisp/cl-ppcre/convert-tmp2OWI3Q7U.fasl
; compilation finished in 0:00:00.136
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/optimize.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/optimize.lisp
; in: DEFMETHOD GATHER-STRINGS (SEQ)
;     (MAKE-ARRAY CL-PPCRE::COLLECTOR-LENGTH :INITIAL-CONTENTS CL-PPCRE::COLLECTOR
;                 :ELEMENT-TYPE 'CHARACTER :FILL-POINTER T :ADJUSTABLE T)
; --&gt; LET TRULY-THE SB-C::MAKE-ARRAY-HEADER* LET 
; ==&gt;
;   (REPLACE SB-C::DATA SB-C::INITIAL-CONTENTS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a VECTOR, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a VECTOR, not a SIMPLE-BASE-STRING.

;     (SETF (SUBSEQ CL-PPCRE::COLLECTOR CL-PPCRE::OLD-COLLECTOR-LENGTH)
;             (CL-PPCRE::STR CL-PPCRE::ELEMENT)
;           CL-PPCRE::SKIP (CL-PPCRE::SKIP CL-PPCRE::ELEMENT))
; --&gt; PROGN SETF LET* 
; ==&gt;
;   (REPLACE #:SEQUENCE #:NEW1 :START1 #:START :END1 NIL)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-BASE-STRING.
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES SIMPLE-BASE-STRING
;                                                            &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY CHARACTER
;                                                      (*))
;                                                     &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY SINGLE-FLOAT
;                                                      (*))
;                                                     &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY DOUBLE-FLOAT (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY DOUBLE-FLOAT (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY DOUBLE-FLOAT
;                                                      (*))
;                                                     &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-BIT-VECTOR.
;   The second argument is a SEQUENCE, not a SIMPLE-BIT-VECTOR.
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES SIMPLE-BIT-VECTOR
;                                                            &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 2) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 2) (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 2) (*))
;                                                     &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 4) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 4) (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 4) (*))
;                                                     &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 7) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 7) (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 7) (*))
;                                                     &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 8) (*))
;                                                     &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 15) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 15)
;                                             (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 15) (*))
;                                                     &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 16) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 16)
;                                             (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 16) (*))
;                                                     &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 31) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 31)
;                                             (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 31) (*))
;                                                     &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 32) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 32)
;                                             (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 32) (*))
;                                                     &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 62) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 62)
;                                             (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 62) (*))
;                                                     &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 63) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 63)
;                                             (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 63) (*))
;                                                     &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 64) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 64)
;                                             (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 64) (*))
;                                                     &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (SIGNED-BYTE 8) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 8) (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (SIGNED-BYTE 8) (*))
;                                                     &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (SIGNED-BYTE 16) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 16) (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (SIGNED-BYTE 16) (*))
;                                                     &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (SIGNED-BYTE 32) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 32) (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (SIGNED-BYTE 32) (*))
;                                                     &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY FIXNUM (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY FIXNUM (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY FIXNUM (*))
;                                                     &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (SIGNED-BYTE 64) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 64) (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (SIGNED-BYTE 64) (*))
;                                                     &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (COMPLEX SINGLE-FLOAT)
;                                          (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX SINGLE-FLOAT)
;                                             (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (COMPLEX SINGLE-FLOAT)
;                                                      (*))
;                                                     &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (COMPLEX DOUBLE-FLOAT)
;                                          (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX DOUBLE-FLOAT)
;                                             (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (COMPLEX DOUBLE-FLOAT)
;                                                      (*))
;                                                     &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-VECTOR.
;   The second argument is a SEQUENCE, not a SIMPLE-VECTOR.
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES SIMPLE-VECTOR &amp;REST
;                                                            T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-BASE-STRING.
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES SIMPLE-BASE-STRING
;                                                            &amp;REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES VECTOR &amp;OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY CHARACTER
;                                                      (*))
;                                                     &amp;REST T).

;     (INCF CL-PPCRE::COLLECTOR-LENGTH (CL-PPCRE::LEN CL-PPCRE::ELEMENT))
; --&gt; SETQ THE 
; ==&gt;
;   (+ (CL-PPCRE::LEN CL-PPCRE::ELEMENT) CL-PPCRE::COLLECTOR-LENGTH)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64)
;                                                                &amp;REST T).
;       etc.

; in: DEFMETHOD START-ANCHORED-P (REPETITION)
;     (PLUSP (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION))
; ==&gt;
;   (&gt; (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

; in: DEFMETHOD START-ANCHORED-P (REGEX)
;     (ZEROP (CL-PPCRE::LEN CL-PPCRE::REGEX))
; ==&gt;
;   (= (CL-PPCRE::LEN CL-PPCRE::REGEX) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

; in: DEFMETHOD END-STRING-AUX (SEQ)
;     (ZEROP (CL-PPCRE::LEN CL-PPCRE::ELEMENT-END))
; --&gt; = IF 
; ==&gt;
;   (= (CL-PPCRE::LEN CL-PPCRE::ELEMENT-END) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

;     (MAKE-ARRAY CL-PPCRE::CONCATENATED-LENGTH :INITIAL-CONTENTS
;                 (REVERSE (CL-PPCRE::STR CL-PPCRE::CONCATENATED-START))
;                 :ELEMENT-TYPE 'CHARACTER :FILL-POINTER T :ADJUSTABLE T)
; --&gt; UNLESS IF = 
; ==&gt;
;   (LENGTH SB-C::INITIAL-CONTENTS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

; --&gt; UNLESS IF ERROR 
; ==&gt;
;   (LENGTH SB-C::INITIAL-CONTENTS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

; --&gt; LET TRULY-THE SB-C::MAKE-ARRAY-HEADER* LET 
; ==&gt;
;   (REPLACE SB-C::DATA SB-C::INITIAL-CONTENTS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL
;                                SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY
;                                                                     CHARACTER
;                                                                     (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL
;                                SB-KERNEL:EXTENDED-SEQUENCE), not a SIMPLE-BASE-STRING.

;     (CHAR CL-PPCRE::STR CL-PPCRE::I)
; --&gt; AREF 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; because:
;   Upgraded element type of array is not known at compile time.

; in: DEFMETHOD COMPUTE-MIN-REST (ALTERNATION T)
;     (LOOP CL-PPCRE::FOR CL-PPCRE::CHOICE CL-PPCRE::IN (CL-PPCRE::CHOICES
;                                                        CL-PPCRE::ALTERNATION)
;           CL-PPCRE::MINIMIZE (CL-PPCRE::COMPUTE-MIN-REST CL-PPCRE::CHOICE
;                               CL-PPCRE::CURRENT-MIN-REST))
; --&gt; BLOCK LET SB-LOOP::WITH-MINIMAX-VALUE LET TAGBODY 
; --&gt; SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF &lt; IF 
; ==&gt;
;   (&lt; #:LOOP-MAXMIN-TEMP-10 #:LOOP-MAXMIN-9)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; in: DEFMETHOD COMPUTE-MIN-REST (BRANCH T)
;     (MIN
;      (CL-PPCRE::COMPUTE-MIN-REST (CL-PPCRE::THEN-REGEX CL-PPCRE::BRANCH)
;       CL-PPCRE::CURRENT-MIN-REST)
;      (CL-PPCRE::COMPUTE-MIN-REST (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)
;       CL-PPCRE::CURRENT-MIN-REST))
; --&gt; LET LET IF &lt;= OR LET &lt; IF 
; ==&gt;
;   (&lt; SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

; --&gt; LET LET IF &lt;= OR LET IF = IF 
; ==&gt;
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --&gt; LET LET IF &lt;= OR LET &lt; IF 
; ==&gt;
;   (&lt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --&gt; LET LET IF &lt;= OR LET IF = IF 
; ==&gt;
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; in: DEFMETHOD COMPUTE-MIN-REST (STR T)
;     (+ CL-PPCRE::CURRENT-MIN-REST (CL-PPCRE::LEN CL-PPCRE::STR))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; in: DEFMETHOD COMPUTE-MIN-REST (FILTER T)
;     (+ CL-PPCRE::CURRENT-MIN-REST (OR (CL-PPCRE::LEN CL-PPCRE::FILTER) 0))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a (NOT NULL), not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; in: DEFMETHOD COMPUTE-MIN-REST (REPETITION T)
;     (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;        (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION))
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES
;                                                         (COMPLEX SINGLE-FLOAT)
;                                                         &amp;REST T).
;       etc.

;     (+ CL-PPCRE::CURRENT-MIN-REST
;        (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;           (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; in: DEFMETHOD COMPUTE-MIN-REST (LOOKBEHIND T)
;     (+ CL-PPCRE::CURRENT-MIN-REST (CL-PPCRE::LEN CL-PPCRE::LOOKBEHIND))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; in: DEFMETHOD COMPUTE-MIN-REST (REGEX T)
;     (1+ CL-PPCRE::CURRENT-MIN-REST)
; ==&gt;
;   (+ CL-PPCRE::CURRENT-MIN-REST 1)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.


; wrote /home/dunham/.cache/common-lisp/sbcl-2.0.10-linux-x64/home/dunham/common-lisp/cl-ppcre/optimize-tmp9KKTJMYV.fasl
; compilation finished in 0:00:00.080
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/closures.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/closures.lisp
; in: DEFUN *STRING*-EQUAL
;     (CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;                 (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; ==&gt;
;   (SB-INT:TWO-ARG-CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;                              (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

; in: DEFMETHOD CREATE-MATCHER-AUX (LOOKBEHIND T)
;     (- CL-PPCRE::START-POS CL-PPCRE::LEN)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

; in: DEFMETHOD CREATE-MATCHER-AUX (CHAR-CLASS T)
;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::CHAR-CLASS
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::START-POS))
;       (LAMBDA (CL-PPCRE::START-POS)
;         (DECLARE (FIXNUM CL-PPCRE::START-POS))
;         (AND (&lt; CL-PPCRE::START-POS CL-PPCRE::*END-POS*)
;              (CL-PPCRE::CHAR-CLASS-TEST)
;              (FUNCALL CL-PPCRE::NEXT-FN (1+ CL-PPCRE::START-POS)))))
; --&gt; LET LET LAMBDA FUNCTION AND IF IF FUNCALL SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL #:TEST-FUNCTION6)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

; in: DEFMETHOD CREATE-MATCHER-AUX (STR T)
;     (CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS) CL-PPCRE::CHR)
; ==&gt;
;   (SB-INT:TWO-ARG-CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::START-POS)
;                              CL-PPCRE::CHR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (LENGTH CL-PPCRE::END-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR CONS VECTOR
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::END-STRING CL-PPCRE::START-POS
;      CL-PPCRE::TEST-END-POS 0 CL-PPCRE::END-STRING-LEN)
; --&gt; BLOCK LOOP BLOCK LET LET TAGBODY UNLESS IF CHAR-EQUAL 
; ==&gt;
;   (SB-INT:TWO-ARG-CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;                              (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::START-POS
;      CL-PPCRE::NEXT-POS 0 CL-PPCRE::LEN)
; --&gt; BLOCK LOOP BLOCK LET LET TAGBODY UNLESS IF CHAR-EQUAL 
; ==&gt;
;   (SB-INT:TWO-ARG-CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;                              (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (+ CL-PPCRE::START-POS CL-PPCRE::LEN)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

; in: DEFMETHOD CREATE-MATCHER-AUX (BACK-REFERENCE T)
;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::*STRING* CL-PPCRE::START-POS
;      CL-PPCRE::NEXT-POS CL-PPCRE::REG-START CL-PPCRE::REG-END)
; --&gt; BLOCK LOOP BLOCK LET LET TAGBODY UNLESS IF CHAR-EQUAL 
; ==&gt;
;   (SB-INT:TWO-ARG-CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;                              (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (+ CL-PPCRE::START-POS
;        (- (THE FIXNUM CL-PPCRE::REG-END) (THE FIXNUM CL-PPCRE::REG-START)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a (INTEGER -9223372036854775807
;                                 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163711 13835058055282163710)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163711 13835058055282163710)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a (INTEGER -9223372036854775807
;                                 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163711 13835058055282163710)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163711 13835058055282163710)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the second argument of GENERIC-+
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the second argument of GENERIC-+

; in: DEFMETHOD CREATE-MATCHER-AUX (FILTER T)
;     (FUNCALL CL-PPCRE::FN CL-PPCRE::START-POS)
; --&gt; SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL CL-PPCRE::FN)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   FN is not known to be a function

;     (FUNCALL CL-PPCRE::NEXT-FN CL-PPCRE::NEXT-POS)
; --&gt; SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL CL-PPCRE::NEXT-FN)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   NEXT-FN is not known to be a function


; wrote /home/dunham/.cache/common-lisp/sbcl-2.0.10-linux-x64/home/dunham/common-lisp/cl-ppcre/closures-tmpJU0JWO19.fasl
; compilation finished in 0:00:00.096
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/repetition-closures.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/repetition-closures.lisp
; in: DEFMETHOD CREATE-GREEDY-CONSTANT-LENGTH-MATCHER (REPETITION T)
;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST)))
; --&gt; LET LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --&gt; BLOCK TAGBODY WHEN IF FUNCALL SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL #:TEST-FUNCTION30)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (CHAR-EQUAL CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
; ==&gt;
;   (SB-INT:TWO-ARG-CHAR-EQUAL CL-PPCRE::CHR
;                              (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::CURR-POS
;                               (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0
;                               CL-PPCRE::LEN)
; --&gt; BLOCK LOOP BLOCK LET LET TAGBODY UNLESS IF CHAR-EQUAL 
; ==&gt;
;   (SB-INT:TWO-ARG-CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;                              (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (FUNCALL CL-PPCRE::INNER-MATCHER CL-PPCRE::CURR-POS))
; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST)))
; --&gt; LET LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --&gt; 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; LET LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --&gt; 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR= CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR-EQUAL CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET IF &lt;= IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR= CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET IF &lt;= IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::CURR-POS
;                                (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0
;                                CL-PPCRE::LEN))
; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET IF &lt;= IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*= CL-PPCRE::STR CL-PPCRE::CURR-POS
;                           (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0 CL-PPCRE::LEN))
; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET IF &lt;= IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST)))
; --&gt; LET LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --&gt; MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; LET LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --&gt; MIN LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; LET LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --&gt; MIN LET LET MIN LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; LET LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --&gt; MIN LET LET IF &lt;= IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR/= #\Newline (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET IF &lt;= IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (FUNCALL CL-PPCRE::INNER-MATCHER CL-PPCRE::CURR-POS))
; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET IF &lt;= IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==&gt;
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR/= #\Newline (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==&gt;
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST)))
; --&gt; LET LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --&gt; 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; LET LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --&gt; MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; LET LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --&gt; MIN LET LET MIN LET 
; ==&gt;
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*= CL-PPCRE::STR CL-PPCRE::CURR-POS
;                           (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0 CL-PPCRE::LEN))
; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==&gt;
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::CURR-POS
;                                (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0
;                                CL-PPCRE::LEN))
; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==&gt;
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR= CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==&gt;
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR-EQUAL CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==&gt;
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

; in: DEFMETHOD CREATE-GREEDY-NO-ZERO-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0)
; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX)
;                                    (THE FIXNUM SB-C::NEW-VALUE))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; LET* + AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* + AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX)
;                                    (THE FIXNUM SB-C::NEW-VALUE))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; LET* SB-IMPL::XSUBTRACT AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS 
; --&gt; THE SB-KERNEL:HAIRY-DATA-VECTOR-REF SB-KERNEL:CHECK-BOUND 
; --&gt; SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* SB-IMPL::XSUBTRACT AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS 
; --&gt; THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX)
;                                    (THE FIXNUM SB-C::NEW-VALUE))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; in: DEFMETHOD CREATE-GREEDY-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0
;           (SVREF CL-PPCRE::*LAST-POS-STORES* CL-PPCRE::ZERO-LENGTH-NUM) NIL)
; --&gt; PROGN SETF LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; PROGN SETF LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX)
;                                    (THE FIXNUM SB-C::NEW-VALUE))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; LET* + AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* + AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX)
;                                    (THE FIXNUM SB-C::NEW-VALUE))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; LET* SB-IMPL::XSUBTRACT AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS 
; --&gt; THE SB-KERNEL:HAIRY-DATA-VECTOR-REF SB-KERNEL:CHECK-BOUND 
; --&gt; SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* SB-IMPL::XSUBTRACT AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS 
; --&gt; THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX)
;                                    (THE FIXNUM SB-C::NEW-VALUE))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; in: DEFMETHOD CREATE-NON-GREEDY-CONSTANT-LENGTH-MATCHER (REPETITION T)
;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST)))
; --&gt; LET LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION 
; --&gt; LET LOOP BLOCK LET LET TAGBODY UNLESS IF FUNCALL SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL #:TEST-FUNCTION102)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::CURR-POS
;                               (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0
;                               CL-PPCRE::LEN)
; --&gt; BLOCK LOOP BLOCK LET LET TAGBODY UNLESS IF CHAR-EQUAL 
; ==&gt;
;   (SB-INT:TWO-ARG-CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;                              (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CHAR-EQUAL CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
; ==&gt;
;   (SB-INT:TWO-ARG-CHAR-EQUAL CL-PPCRE::CHR
;                              (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::CURR-POS
;                               (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0
;                               CL-PPCRE::LEN)
; --&gt; BLOCK LOOP BLOCK LET LET TAGBODY UNLESS IF CHAR-EQUAL 
; ==&gt;
;   (SB-INT:TWO-ARG-CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;                              (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*= CL-PPCRE::STR CL-PPCRE::CURR-POS
;                           (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0 CL-PPCRE::LEN))
; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::CURR-POS
;                                (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0
;                                CL-PPCRE::LEN))
; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET IF &lt;= IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR= CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET IF &lt;= IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR-EQUAL CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET IF &lt;= IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*= CL-PPCRE::STR CL-PPCRE::CURR-POS
;                           (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0 CL-PPCRE::LEN))
; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET IF &lt;= IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST)))
; --&gt; LET LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION 
; --&gt; LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; LET LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION 
; --&gt; LET MIN LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; LET LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION 
; --&gt; LET MIN LET LET MIN LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; LET LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION 
; --&gt; LET MIN LET LET IF &lt;= IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

; --&gt; LET LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION 
; --&gt; LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; LET LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION 
; --&gt; LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE T)
; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET IF &lt;= IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR/= #\Newline (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET IF &lt;= IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (FUNCALL CL-PPCRE::INNER-MATCHER CL-PPCRE::CURR-POS))
; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET IF &lt;= IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET 1+ 
; ==&gt;
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==&gt;
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR/= #\Newline (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==&gt;
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE T)
; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==&gt;
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST)))
; --&gt; LET LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION 
; --&gt; LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; LET LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION 
; --&gt; LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; LET LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION 
; --&gt; LET MIN LET LET MIN LET 
; ==&gt;
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*= CL-PPCRE::STR CL-PPCRE::CURR-POS
;                           (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0 CL-PPCRE::LEN))
; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==&gt;
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::CURR-POS
;                                (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0
;                                CL-PPCRE::LEN))
; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==&gt;
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR= CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==&gt;
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR-EQUAL CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --&gt; IF LAMBDA FUNCTION LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==&gt;
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --&gt; IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==&gt;
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

; in: DEFMETHOD CREATE-NON-GREEDY-NO-ZERO-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0)
; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX)
;                                    (THE FIXNUM SB-C::NEW-VALUE))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; LET* + AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* + AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX)
;                                    (THE FIXNUM SB-C::NEW-VALUE))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; LET* SB-IMPL::XSUBTRACT AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS 
; --&gt; THE SB-KERNEL:HAIRY-DATA-VECTOR-REF SB-KERNEL:CHECK-BOUND 
; --&gt; SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* SB-IMPL::XSUBTRACT AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS 
; --&gt; THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX)
;                                    (THE FIXNUM SB-C::NEW-VALUE))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; in: DEFMETHOD CREATE-NON-GREEDY-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0
;           (SVREF CL-PPCRE::*LAST-POS-STORES* CL-PPCRE::ZERO-LENGTH-NUM) NIL)
; --&gt; PROGN SETF LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; PROGN SETF LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX)
;                                    (THE FIXNUM SB-C::NEW-VALUE))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; LET* + AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* + AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX)
;                                    (THE FIXNUM SB-C::NEW-VALUE))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; LET* SB-IMPL::XSUBTRACT AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS 
; --&gt; THE SB-KERNEL:HAIRY-DATA-VECTOR-REF SB-KERNEL:CHECK-BOUND 
; --&gt; SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* SB-IMPL::XSUBTRACT AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS 
; --&gt; THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX)
;                                    (THE FIXNUM SB-C::NEW-VALUE))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; in:
;      DEFMETHOD CREATE-CONSTANT-REPETITION-CONSTANT-LENGTH-MATCHER (REPETITION T)
;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;        (AND (CL-PPCRE::CHAR-CLASS-TEST) (1+ CL-PPCRE::CURR-POS))))
; --&gt; LET LET CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE LAMBDA 
; --&gt; FUNCTION LET AND IF IF LOOP BLOCK LET TAGBODY UNLESS IF AND IF FUNCALL 
; --&gt; SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL #:TEST-FUNCTION36)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (CHAR-EQUAL CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
; ==&gt;
;   (SB-INT:TWO-ARG-CHAR-EQUAL CL-PPCRE::CHR
;                              (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::CURR-POS CL-PPCRE::NEXT-POS
;                               0 CL-PPCRE::LEN)
; --&gt; BLOCK LOOP BLOCK LET LET TAGBODY UNLESS IF CHAR-EQUAL 
; ==&gt;
;   (SB-INT:TWO-ARG-CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;                              (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;      (LET ((CL-PPCRE::NEXT-POS (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN)))
;        (DECLARE (FIXNUM CL-PPCRE::NEXT-POS))
;        (AND
;         (CL-PPCRE::*STRING*= CL-PPCRE::STR CL-PPCRE::CURR-POS CL-PPCRE::NEXT-POS
;                              0 CL-PPCRE::LEN)
;         CL-PPCRE::NEXT-POS)))
; --&gt; LAMBDA FUNCTION LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::REPETITIONS)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

;     (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;      (AND
;       (CHAR-EQUAL CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
;       (1+ CL-PPCRE::CURR-POS)))
; --&gt; LAMBDA FUNCTION LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::REPETITIONS)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

;     (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;      (AND (CHAR= CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
;           (1+ CL-PPCRE::CURR-POS)))
; --&gt; LAMBDA FUNCTION LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::REPETITIONS)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

;     (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;      (LET ((CL-PPCRE::NEXT-POS (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN)))
;        (DECLARE (FIXNUM CL-PPCRE::NEXT-POS))
;        (AND
;         (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::CURR-POS
;                                   CL-PPCRE::NEXT-POS 0 CL-PPCRE::LEN)
;         CL-PPCRE::NEXT-POS)))
; --&gt; LAMBDA FUNCTION LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::REPETITIONS)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;        (AND (CL-PPCRE::CHAR-CLASS-TEST) (1+ CL-PPCRE::CURR-POS))))
; --&gt; LET LET CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE LAMBDA 
; --&gt; FUNCTION LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::REPETITIONS)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

;     (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;      (AND (CHAR/= #\Newline (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS))
;           (1+ CL-PPCRE::CURR-POS)))
; --&gt; LAMBDA FUNCTION LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::REPETITIONS)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

;     (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;      (FUNCALL CL-PPCRE::INNER-MATCHER CL-PPCRE::CURR-POS))
; --&gt; LAMBDA FUNCTION LET + THE 
; ==&gt;
;   (* CL-PPCRE::LEN CL-PPCRE::REPETITIONS)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The result is a (VALUES
;                        (INTEGER -21267647932558653961849226946058125312
;                         21267647932558653966460912964485513216)
;                        &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &amp;REST T).
;       etc.

; in: DEFMETHOD CREATE-CONSTANT-REPETITION-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0)
; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX)
;                                    (THE FIXNUM SB-C::NEW-VALUE))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; LET* + AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* + AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX)
;                                    (THE FIXNUM SB-C::NEW-VALUE))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; LET* SB-IMPL::XSUBTRACT AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS 
; --&gt; THE SB-KERNEL:HAIRY-DATA-VECTOR-REF SB-KERNEL:CHECK-BOUND 
; --&gt; SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* SB-IMPL::XSUBTRACT AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS 
; --&gt; THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX)
;                                    (THE FIXNUM SB-C::NEW-VALUE))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0
;           (AREF CL-PPCRE::*LAST-POS-STORES* CL-PPCRE::ZERO-LENGTH-NUM) NIL)
; --&gt; PROGN SETF LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; PROGN SETF LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX)
;                                    (THE FIXNUM SB-C::NEW-VALUE))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (ZEROP (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION))
; ==&gt;
;   (= (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; LET* + AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-REF SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* + AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX)
;                                    (THE FIXNUM SB-C::NEW-VALUE))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --&gt; LET* SB-IMPL::XSUBTRACT AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS 
; --&gt; THE SB-KERNEL:HAIRY-DATA-VECTOR-REF SB-KERNEL:CHECK-BOUND 
; --&gt; SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* SB-IMPL::XSUBTRACT AREF SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS 
; --&gt; THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET SB-KERNEL:CHECK-BOUND SB-C::BOUND-CAST 
; ==&gt;
;   (SB-KERNEL:%CHECK-BOUND ARRAY SB-C::DIMENSION SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a (SIMPLE-ARRAY * (*)).

; --&gt; LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; --&gt; SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS TRULY-THE 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY
;                                    (SB-KERNEL:CHECK-BOUND ARRAY
;                                                           (ARRAY-DIMENSION
;                                                            ARRAY 0)
;                                                           SB-INT:INDEX)
;                                    (THE FIXNUM SB-C::NEW-VALUE))
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; in: DEFMETHOD CREATE-MATCHER-AUX (REPETITION T)
;     (AND CL-PPCRE::MAXIMUM (ZEROP CL-PPCRE::MAXIMUM))
; --&gt; IF ZEROP 
; ==&gt;
;   (=
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MAXIMUM)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MAXIMUM))
;    0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

;     (AND CL-PPCRE::MAXIMUM (= CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM 1))
; --&gt; IF = 
; --&gt; (LAMBDA (#:G8 #:G7 #:G6) (DECLARE (TYPE NUMBER #:G8 #:G7 #:G6)) (IF (= #:G8 #:G7) (IF (= #:G7 #:G6) T NIL) NIL)) 
; --&gt; SB-C::%FUNCALL IF 
; ==&gt;
;   (= #:G8 #:G7)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --&gt; IF = 
; --&gt; (LAMBDA (#:G8 #:G7 #:G6) (DECLARE (TYPE NUMBER #:G8 #:G7 #:G6)) (IF (= #:G8 #:G7) (IF (= #:G7 #:G6) T NIL) NIL)) 
; --&gt; SB-C::%FUNCALL IF IF 
; ==&gt;
;   (= #:G7 #:G6)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR SINGLE-FLOAT DOUBLE-FLOAT RATIONAL
;                               (COMPLEX SINGLE-FLOAT) (COMPLEX DOUBLE-FLOAT)
;                               (COMPLEX RATIONAL)), not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR SINGLE-FLOAT DOUBLE-FLOAT RATIONAL
;                               (COMPLEX SINGLE-FLOAT) (COMPLEX DOUBLE-FLOAT)
;                               (COMPLEX RATIONAL)), not a (OR
;                                                           (COMPLEX
;                                                            SINGLE-FLOAT)
;                                                           (COMPLEX
;                                                            DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

;     (OR (PLUSP CL-PPCRE::MIN-LEN) (EQL CL-PPCRE::MAXIMUM 1))
; --&gt; LET PLUSP &gt; IF 
; ==&gt;
;   (&gt;
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MIN-LEN)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MIN-LEN))
;    0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (AND CL-PPCRE::LEN (PLUSP CL-PPCRE::LEN) (NOT CL-PPCRE::CONTAINS-REGISTER-P))
; --&gt; IF IF PLUSP 
; ==&gt;
;   (&gt;
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::LEN)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::LEN))
;    0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (OR (PLUSP CL-PPCRE::MIN-LEN) (EQL CL-PPCRE::MAXIMUM 1))
; --&gt; LET PLUSP &gt; IF 
; ==&gt;
;   (&gt;
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MIN-LEN)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MIN-LEN))
;    0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (AND CL-PPCRE::MAXIMUM (= CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM 1))
; --&gt; IF = 
; --&gt; (LAMBDA (#:G8 #:G7 #:G6) (DECLARE (TYPE NUMBER #:G8 #:G7 #:G6)) (IF (= #:G8 #:G7) (IF (= #:G7 #:G6) T NIL) NIL)) 
; --&gt; SB-C::%FUNCALL IF 
; ==&gt;
;   (= #:G8 #:G7)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

;     (AND (EQL CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM) CL-PPCRE::LEN
;          (NOT CL-PPCRE::CONTAINS-REGISTER-P))
; --&gt; IF IF 
; ==&gt;
;   (EQL
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MINIMUM)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MINIMUM))
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MAXIMUM)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MAXIMUM)))
; 
; note: forced to do IF-EQL (cost 15)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (COND
;      ((AND CL-PPCRE::MAXIMUM (ZEROP CL-PPCRE::MAXIMUM))
;       (ERROR &quot;Got REPETITION with MAXIMUM 0 (should not happen)&quot;))
;      ((AND CL-PPCRE::MAXIMUM (= CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM 1))
;       (ERROR &quot;Got REPETITION with MAXIMUM 1 and MINIMUM 1 (should not happen)&quot;))
;      ((AND (EQL CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM) CL-PPCRE::LEN
;            (NOT CL-PPCRE::CONTAINS-REGISTER-P))
;       (CL-PPCRE::CREATE-CONSTANT-REPETITION-CONSTANT-LENGTH-MATCHER
;        CL-PPCRE::REPETITION CL-PPCRE::NEXT-FN))
;      ((EQL CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM)
;       (CL-PPCRE::CREATE-CONSTANT-REPETITION-MATCHER CL-PPCRE::REPETITION
;        CL-PPCRE::NEXT-FN))
;      ((AND CL-PPCRE::GREEDYP CL-PPCRE::LEN (NOT CL-PPCRE::CONTAINS-REGISTER-P))
;       (CL-PPCRE::CREATE-GREEDY-CONSTANT-LENGTH-MATCHER CL-PPCRE::REPETITION
;        CL-PPCRE::NEXT-FN))
;      ((AND CL-PPCRE::GREEDYP
;            (OR (PLUSP CL-PPCRE::MIN-LEN) (EQL CL-PPCRE::MAXIMUM 1)))
;       (CL-PPCRE::CREATE-GREEDY-NO-ZERO-MATCHER CL-PPCRE::REPETITION
;        CL-PPCRE::NEXT-FN))
;      (CL-PPCRE::GREEDYP
;       (CL-PPCRE::CREATE-GREEDY-MATCHER CL-PPCRE::REPETITION CL-PPCRE::NEXT-FN))
;      ((AND CL-PPCRE::LEN (PLUSP CL-PPCRE::LEN)
;            (NOT CL-PPCRE::CONTAINS-REGISTER-P))
;       (CL-PPCRE::CREATE-NON-GREEDY-CONSTANT-LENGTH-MATCHER CL-PPCRE::REPETITION
;        CL-PPCRE::NEXT-FN))
;      ((OR (PLUSP CL-PPCRE::MIN-LEN) (EQL CL-PPCRE::MAXIMUM 1))
;       (CL-PPCRE::CREATE-NON-GREEDY-NO-ZERO-MATCHER CL-PPCRE::REPETITION
;        CL-PPCRE::NEXT-FN))
;      (T
;       (CL-PPCRE::CREATE-NON-GREEDY-MATCHER CL-PPCRE::REPETITION
;        CL-PPCRE::NEXT-FN)))
; --&gt; IF IF IF IF 
; ==&gt;
;   (EQL
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MINIMUM)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MINIMUM))
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MAXIMUM)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MAXIMUM)))
; 
; note: forced to do IF-EQL (cost 15)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (OR (PLUSP CL-PPCRE::MIN-LEN) (EQL CL-PPCRE::MAXIMUM 1))
; --&gt; LET PLUSP &gt; IF 
; ==&gt;
;   (&gt;
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MIN-LEN)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MIN-LEN))
;    0)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (AND CL-PPCRE::LEN (PLUSP CL-PPCRE::LEN) (NOT CL-PPCRE::CONTAINS-REGISTER-P))
; --&gt; IF IF PLUSP 
; ==&gt;
;   (&gt;
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::LEN)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::LEN))
;    0)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (OR (PLUSP CL-PPCRE::MIN-LEN) (EQL CL-PPCRE::MAXIMUM 1))
; --&gt; LET PLUSP &gt; IF 
; ==&gt;
;   (&gt;
;    (SB-C::WITH-SOURCE-FORM (SLOT-VALUE #:G0 'CL-PPCRE::MIN-LEN)
;                            (SB-PCL::ACCESSOR-SLOT-VALUE #:G0
;                                                         'CL-PPCRE::MIN-LEN))
;    0)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.


; wrote /home/dunham/.cache/common-lisp/sbcl-2.0.10-linux-x64/home/dunham/common-lisp/cl-ppcre/repetition-closures-tmpZX2WN8N4.fasl
; compilation finished in 0:00:00.304
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/scanner.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/scanner.lisp
; in: DEFUN CREATE-BMH-MATCHER
;     (CL-PPCRE::BMH-MATCHER-AUX :CASE-INSENSITIVE-P T)
; --&gt; LAMBDA FUNCTION IF LOOP BLOCK LET TAGBODY LOOP BLOCK LET LET TAGBODY 
; --&gt; UNLESS IF AND IF CHAR-EQUAL 
; ==&gt;
;   (SB-INT:TWO-ARG-CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::I)
;                              (SCHAR CL-PPCRE::PATTERN CL-PPCRE::J))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (LENGTH CL-PPCRE::PATTERN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CHAR-UPCASE (SCHAR CL-PPCRE::PATTERN CL-PPCRE::K))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (CHAR-DOWNCASE (SCHAR CL-PPCRE::PATTERN CL-PPCRE::K))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (SEARCH CL-PPCRE::PATTERN CL-PPCRE::*STRING* :START2 CL-PPCRE::START-POS
;             :END2 CL-PPCRE::*END-POS* :TEST CL-PPCRE::TEST)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; in: DEFUN CREATE-CHAR-SEARCHER
;     (CL-PPCRE::CHAR-SEARCHER-AUX :CASE-INSENSITIVE-P T)
; --&gt; LAMBDA FUNCTION AND IF LOOP BLOCK LET LET TAGBODY WHEN IF SETQ THE AND IF 
; --&gt; CHAR-EQUAL 
; ==&gt;
;   (SB-INT:TWO-ARG-CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::I)
;                              CL-PPCRE::CHR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS) CL-PPCRE::POS))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (IF (&lt;= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF LOCALLY COND IF 
; --&gt; AND IF NOT IF CL-PPCRE::*STRING*-EQUAL BLOCK LOOP BLOCK LET LET TAGBODY 
; --&gt; UNLESS IF CHAR-EQUAL 
; ==&gt;
;   (SB-INT:TWO-ARG-CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;                              (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS) CL-PPCRE::POS))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= OR 
; --&gt; LET IF = IF 
; ==&gt;
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (IF (&lt;= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF LOCALLY COND IF 
; --&gt; AND IF NOT IF CL-PPCRE::*STRING*-EQUAL BLOCK LOOP BLOCK LET LET TAGBODY 
; --&gt; UNLESS IF CHAR-EQUAL 
; ==&gt;
;   (SB-INT:TWO-ARG-CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;                              (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= OR 
; --&gt; LET IF = IF 
; ==&gt;
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::START-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF LOCALLY COND IF 
; --&gt; AND IF NOT IF CL-PPCRE::*STRING*-EQUAL BLOCK LOOP BLOCK LET LET TAGBODY 
; --&gt; UNLESS IF CHAR-EQUAL 
; ==&gt;
;   (SB-INT:TWO-ARG-CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;                              (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       (IF (&lt;= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF LOCALLY COND IF 
; --&gt; AND IF NOT IF CL-PPCRE::*STRING*-EQUAL BLOCK LOOP BLOCK LET LET TAGBODY 
; --&gt; UNLESS IF CHAR-EQUAL 
; ==&gt;
;   (SB-INT:TWO-ARG-CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;                              (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       (IF (&lt;= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= OR 
; --&gt; LET IF = IF 
; ==&gt;
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET CL-PPCRE::STARTS-WITH-LEN)
;                (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= OR 
; --&gt; LET IF = IF 
; ==&gt;
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       (IF (&lt;= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF LOCALLY COND IF 
; --&gt; AND IF NOT IF CL-PPCRE::*STRING*-EQUAL BLOCK LOOP BLOCK LET LET TAGBODY 
; --&gt; UNLESS IF CHAR-EQUAL 
; ==&gt;
;   (SB-INT:TWO-ARG-CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;                              (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET)
;                (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF LOCALLY COND IF 
; --&gt; AND IF NOT IF CL-PPCRE::*STRING*-EQUAL BLOCK LOOP BLOCK LET LET TAGBODY 
; --&gt; UNLESS IF CHAR-EQUAL 
; ==&gt;
;   (SB-INT:TWO-ARG-CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;                              (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::START-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= OR 
; --&gt; LET IF = IF 
; ==&gt;
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET CL-PPCRE::STARTS-WITH-LEN)
;                (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF LOCALLY COND IF 
; --&gt; AND IF NOT IF CL-PPCRE::*STRING*-EQUAL BLOCK LOOP BLOCK LET LET TAGBODY 
; --&gt; UNLESS IF CHAR-EQUAL 
; ==&gt;
;   (SB-INT:TWO-ARG-CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;                              (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET)
;                (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= OR 
; --&gt; LET IF = IF 
; ==&gt;
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET CL-PPCRE::STARTS-WITH-LEN)
;                (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (IF (&lt;= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= OR 
; --&gt; LET IF = IF 
; ==&gt;
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS) CL-PPCRE::POS))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF LOCALLY COND IF 
; --&gt; AND IF NOT IF CL-PPCRE::*STRING*-EQUAL BLOCK LOOP BLOCK LET LET TAGBODY 
; --&gt; UNLESS IF CHAR-EQUAL 
; ==&gt;
;   (SB-INT:TWO-ARG-CHAR-EQUAL (SCHAR CL-PPCRE::*STRING* CL-PPCRE::STRING1-IDX)
;                              (SCHAR CL-PPCRE::STRING2 CL-PPCRE::STRING2-IDX))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.
;   The second argument is a CHARACTER, not a BASE-CHAR.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       (IF (&lt;= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= OR 
; --&gt; LET IF = IF 
; ==&gt;
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= OR 
; --&gt; LET &lt; IF 
; ==&gt;
;   (&lt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       (IF (&lt;= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= OR 
; --&gt; LET &lt; IF 
; ==&gt;
;   (&lt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET CL-PPCRE::STARTS-WITH-LEN)
;                (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= OR 
; --&gt; LET &lt; IF 
; ==&gt;
;   (&lt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET)
;                (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= OR 
; --&gt; LET &lt; IF 
; ==&gt;
;   (&lt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::START-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= OR 
; --&gt; LET &lt; IF 
; ==&gt;
;   (&lt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= OR 
; --&gt; LET &lt; IF 
; ==&gt;
;   (&lt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (IF (&lt;= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= OR 
; --&gt; LET &lt; IF 
; ==&gt;
;   (&lt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS) CL-PPCRE::POS))
; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF &lt;= OR 
; --&gt; LET &lt; IF 
; ==&gt;
;   (&lt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF &lt; 
; ==&gt;
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF AND IF 
; ==&gt;
;   (&lt; (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.

; --&gt; LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --&gt; TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (FUNCALL CL-PPCRE::END-STRING-TEST CL-PPCRE::TRY-POS)
; --&gt; SB-C::%FUNCALL 
; ==&gt;
;   CL-PPCRE::TRY-POS
; 
; note: doing signed word to integer coercion (cost 20) from TRY-POS
; 
; note: doing signed word to integer coercion (cost 20) from TRY-POS


; wrote /home/dunham/.cache/common-lisp/sbcl-2.0.10-linux-x64/home/dunham/common-lisp/cl-ppcre/scanner-tmpOU81XRV0.fasl
; compilation finished in 0:00:00.388
; compiling file &quot;/home/dunham/common-lisp/cl-ppcre/api.lisp&quot; (written 07 APR 2019 08:51:26 AM):

; file: /home/dunham/common-lisp/cl-ppcre/api.lisp
; in: DEFMETHOD CREATE-SCANNER (STRING)
;     (COPY-SEQ CL-PPCRE::QUOTED-REGEX-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

; in: DEFMETHOD CREATE-SCANNER (T)
;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::END-STRING))
; ==&gt;
;   (&gt; (CL-PPCRE::LEN CL-PPCRE::END-STRING) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (= 1 (CL-PPCRE::LEN CL-PPCRE::END-STRING))
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH))
; ==&gt;
;   (&gt; (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (= 1 (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH))
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::END-STRING))
; ==&gt;
;   (&gt; (CL-PPCRE::LEN CL-PPCRE::END-STRING) 0)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH))
; ==&gt;
;   (&gt; (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH) 0)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

; in: DEFMETHOD SCAN (STRING T)
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (FUNCALL (CL-PPCRE:CREATE-SCANNER CL-PPCRE::REGEX-STRING)
;              (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
;              CL-PPCRE::START CL-PPCRE::END)
; --&gt; SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL
;    (CL-PPCRE:CREATE-SCANNER CL-PPCRE::REGEX-STRING))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
; --&gt; LET COND IF THE COERCE THE IF REPLACE MAKE-ARRAY 
; ==&gt;
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR CONS NULL
;                               (AND (NOT (SIMPLE-ARRAY CHARACTER (*)))
;                                    (NOT (SIMPLE-ARRAY NIL (*)))
;                                    (NOT SIMPLE-BASE-STRING) VECTOR)
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

; in: DEFMETHOD SCAN #'T
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
; --&gt; LET COND IF THE COERCE THE IF REPLACE MAKE-ARRAY 
; ==&gt;
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR CONS NULL
;                               (AND (NOT (SIMPLE-ARRAY CHARACTER (*)))
;                                    (NOT (SIMPLE-ARRAY NIL (*)))
;                                    (NOT SIMPLE-BASE-STRING) VECTOR)
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

; in: DEFMETHOD SCAN (T T)
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (FUNCALL (CL-PPCRE:CREATE-SCANNER CL-PPCRE::PARSE-TREE)
;              (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
;              CL-PPCRE::START CL-PPCRE::END)
; --&gt; SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL
;    (CL-PPCRE:CREATE-SCANNER CL-PPCRE::PARSE-TREE))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
; --&gt; LET COND IF THE COERCE THE IF REPLACE MAKE-ARRAY 
; ==&gt;
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR CONS NULL
;                               (AND (NOT (SIMPLE-ARRAY CHARACTER (*)))
;                                    (NOT (SIMPLE-ARRAY NIL (*)))
;                                    (NOT SIMPLE-BASE-STRING) VECTOR)
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

; in: DEFUN SCAN-TO-STRINGS
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (MAP 'VECTOR
;          (LAMBDA (CL-PPCRE::REG-START CL-PPCRE::REG-END)
;            (IF CL-PPCRE::REG-START
;                (FUNCALL CL-PPCRE::SUBSTR-FN CL-PPCRE::TARGET-STRING
;                         CL-PPCRE::REG-START CL-PPCRE::REG-END)
;                NIL))
;          CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS)
; --&gt; TRULY-THE SB-KERNEL:%MAP MAP-INTO LOCALLY MAKE-SEQUENCE MIN LET 
; ==&gt;
;   (LENGTH #:G33)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --&gt; TRULY-THE SB-KERNEL:%MAP MAP-INTO LOCALLY MAKE-SEQUENCE MIN LET LET MIN 
; --&gt; LET 
; ==&gt;
;   (LENGTH #:G34)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; in: DEFUN ALL-MATCHES
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-MATCHES (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                           CL-PPCRE::REGEX CL-PPCRE::TARGET-STRING
;                           (NREVERSE CL-PPCRE::RESULT-LIST) :START CL-PPCRE::START
;                           :END CL-PPCRE::END)
;       (PUSH CL-PPCRE::MATCH-START CL-PPCRE::RESULT-LIST)
;       (PUSH CL-PPCRE::MATCH-END CL-PPCRE::RESULT-LIST))
; --&gt; CL-PPCRE:DO-SCANS LET BLOCK LET* OR LET IF 
; ==&gt;
;   (LENGTH #:TARGET-STRING3)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --&gt; CL-PPCRE:DO-SCANS LET BLOCK LET* SETQ THE 
; --&gt; CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND IF THE COERCE THE IF 
; --&gt; REPLACE MAKE-ARRAY 
; ==&gt;
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR CONS NULL
;                               (AND (NOT (SIMPLE-ARRAY CHARACTER (*)))
;                                    (NOT (SIMPLE-ARRAY NIL (*)))
;                                    (NOT SIMPLE-BASE-STRING) VECTOR)
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

; --&gt; CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK TAGBODY PROGN 
; --&gt; MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==&gt;
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --&gt; CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK TAGBODY PROGN 
; --&gt; MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==&gt;
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a (OR SINGLE-FLOAT DOUBLE-FLOAT RATIONAL
;                               (COMPLEX SINGLE-FLOAT) (COMPLEX DOUBLE-FLOAT)
;                               (COMPLEX RATIONAL)), not a RATIONAL.

; --&gt; CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK TAGBODY PROGN 
; --&gt; MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==&gt;
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; --&gt; CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK TAGBODY PROGN 
; --&gt; MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==&gt;
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR SINGLE-FLOAT DOUBLE-FLOAT RATIONAL
;                                   (COMPLEX SINGLE-FLOAT) (COMPLEX DOUBLE-FLOAT)
;                                   (COMPLEX RATIONAL)), not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR SINGLE-FLOAT DOUBLE-FLOAT RATIONAL
;                                   (COMPLEX SINGLE-FLOAT) (COMPLEX DOUBLE-FLOAT)
;                                   (COMPLEX RATIONAL)), not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; in: DEFUN ALL-MATCHES-AS-STRINGS
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-MATCHES-AS-STRINGS (CL-PPCRE::MATCH CL-PPCRE::REGEX
;                                      CL-PPCRE::TARGET-STRING
;                                      (NREVERSE CL-PPCRE::RESULT-LIST) :START
;                                      CL-PPCRE::START :END CL-PPCRE::END :SHAREDP
;                                      CL-PPCRE::SHAREDP)
;       (PUSH CL-PPCRE::MATCH CL-PPCRE::RESULT-LIST))
; --&gt; LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* OR LET IF 
; ==&gt;
;   (LENGTH #:TARGET-STRING7)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --&gt; LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* SETQ THE 
; --&gt; CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND IF THE COERCE THE IF 
; --&gt; REPLACE MAKE-ARRAY 
; ==&gt;
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR CONS NULL
;                               (AND (NOT (SIMPLE-ARRAY CHARACTER (*)))
;                                    (NOT (SIMPLE-ARRAY NIL (*)))
;                                    (NOT SIMPLE-BASE-STRING) VECTOR)
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

; --&gt; LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK 
; --&gt; TAGBODY PROGN MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE 
; --&gt; IF 
; ==&gt;
;   (= #:MATCH-START2 #:MATCH-END3)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --&gt; LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK 
; --&gt; TAGBODY PROGN MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE 
; --&gt; IF 1+ 
; ==&gt;
;   (+ #:MATCH-END3 1)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a (OR SINGLE-FLOAT DOUBLE-FLOAT RATIONAL
;                               (COMPLEX SINGLE-FLOAT) (COMPLEX DOUBLE-FLOAT)
;                               (COMPLEX RATIONAL)), not a RATIONAL.

; --&gt; LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK 
; --&gt; TAGBODY PROGN MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE 
; --&gt; IF 
; ==&gt;
;   (= #:MATCH-START2 #:MATCH-END3)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; --&gt; LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK 
; --&gt; TAGBODY PROGN MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE 
; --&gt; IF 1+ 
; ==&gt;
;   (+ #:MATCH-END3 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR SINGLE-FLOAT DOUBLE-FLOAT RATIONAL
;                                   (COMPLEX SINGLE-FLOAT) (COMPLEX DOUBLE-FLOAT)
;                                   (COMPLEX RATIONAL)), not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR SINGLE-FLOAT DOUBLE-FLOAT RATIONAL
;                                   (COMPLEX SINGLE-FLOAT) (COMPLEX DOUBLE-FLOAT)
;                                   (COMPLEX RATIONAL)), not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

; in: DEFUN SPLIT
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-SCANS (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                         CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS CL-PPCRE::REGEX
;                         CL-PPCRE::TARGET-STRING NIL :START CL-PPCRE::START :END
;                         CL-PPCRE::END)
;       (UNLESS
;           (AND (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
;                (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST)))
;         (WHEN
;             (AND CL-PPCRE::LIMIT (PLUSP CL-PPCRE::LIMIT) (&gt;= # CL-PPCRE::LIMIT))
;           (RETURN))
;         (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;         (WHEN CL-PPCRE::WITH-REGISTERS-P
;           (LOOP CL-PPCRE::FOR CL-PPCRE::REG-START CL-PPCRE::ACROSS CL-PPCRE::REG-STARTS
;                 CL-PPCRE::FOR CL-PPCRE::REG-END CL-PPCRE::ACROSS CL-PPCRE::REG-ENDS
;                 IF CL-PPCRE::REG-START
;                 DO ...))
;         (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)))
; --&gt; LET BLOCK LET* OR LET IF 
; ==&gt;
;   (LENGTH #:TARGET-STRING1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --&gt; LET BLOCK LET* SETQ THE CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND 
; --&gt; IF THE COERCE THE IF REPLACE MAKE-ARRAY 
; ==&gt;
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR CONS NULL
;                               (AND (NOT (SIMPLE-ARRAY CHARACTER (*)))
;                                    (NOT (SIMPLE-ARRAY NIL (*)))
;                                    (NOT SIMPLE-BASE-STRING) VECTOR)
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

;     (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST))
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR SINGLE-FLOAT DOUBLE-FLOAT RATIONAL
;                               (COMPLEX SINGLE-FLOAT) (COMPLEX DOUBLE-FLOAT)
;                               (COMPLEX RATIONAL)), not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR SINGLE-FLOAT DOUBLE-FLOAT RATIONAL
;                               (COMPLEX SINGLE-FLOAT) (COMPLEX DOUBLE-FLOAT)
;                               (COMPLEX RATIONAL)), not a (OR
;                                                           (COMPLEX
;                                                            SINGLE-FLOAT)
;                                                           (COMPLEX
;                                                            DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (PLUSP CL-PPCRE::LIMIT)
; ==&gt;
;   (&gt; CL-PPCRE::LIMIT 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (LOOP CL-PPCRE::FOR CL-PPCRE::REG-START CL-PPCRE::ACROSS CL-PPCRE::REG-STARTS
;           CL-PPCRE::FOR CL-PPCRE::REG-END CL-PPCRE::ACROSS CL-PPCRE::REG-ENDS
;           IF CL-PPCRE::REG-START
;           DO ...)
; --&gt; BLOCK LET LET LET LET TAGBODY SB-LOOP::LOOP-DESETQ SETQ THE AREF 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; because:
;   Upgraded element type of array is not known at compile time.
; 
; note: unable to
;   optimize
; because:
;   Upgraded element type of array is not known at compile time.

;     (CL-PPCRE:DO-SCANS (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                         CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS CL-PPCRE::REGEX
;                         CL-PPCRE::TARGET-STRING NIL :START CL-PPCRE::START :END
;                         CL-PPCRE::END)
;       (UNLESS
;           (AND (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
;                (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST)))
;         (WHEN
;             (AND CL-PPCRE::LIMIT (PLUSP CL-PPCRE::LIMIT) (&gt;= # CL-PPCRE::LIMIT))
;           (RETURN))
;         (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;         (WHEN CL-PPCRE::WITH-REGISTERS-P
;           (LOOP CL-PPCRE::FOR CL-PPCRE::REG-START CL-PPCRE::ACROSS CL-PPCRE::REG-STARTS
;                 CL-PPCRE::FOR CL-PPCRE::REG-END CL-PPCRE::ACROSS CL-PPCRE::REG-ENDS
;                 IF CL-PPCRE::REG-START
;                 DO ...))
;         (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)))
; --&gt; LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --&gt; MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==&gt;
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --&gt; LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --&gt; MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==&gt;
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a (OR SINGLE-FLOAT DOUBLE-FLOAT RATIONAL
;                               (COMPLEX SINGLE-FLOAT) (COMPLEX DOUBLE-FLOAT)
;                               (COMPLEX RATIONAL)), not a RATIONAL.

;     (&gt; CL-PPCRE::THIS-END CL-PPCRE::THIS-START)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

;     (&gt;= (INCF CL-PPCRE::COUNTER) CL-PPCRE::LIMIT)
; --&gt; OR LET IF = IF 
; ==&gt;
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

;     (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST))
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (OR SINGLE-FLOAT DOUBLE-FLOAT RATIONAL
;                                   (COMPLEX SINGLE-FLOAT) (COMPLEX DOUBLE-FLOAT)
;                                   (COMPLEX RATIONAL)), not a DOUBLE-FLOAT.
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (OR SINGLE-FLOAT DOUBLE-FLOAT RATIONAL
;                                   (COMPLEX SINGLE-FLOAT) (COMPLEX DOUBLE-FLOAT)
;                                   (COMPLEX RATIONAL)), not a (COMPLEX
;                                                               DOUBLE-FLOAT).
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

;     (PLUSP CL-PPCRE::LIMIT)
; ==&gt;
;   (&gt; CL-PPCRE::LIMIT 0)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (NOT NULL), not a FIXNUM.
;       etc.

;     (INCF CL-PPCRE::COUNTER)
; --&gt; SETQ THE 
; ==&gt;
;   (+ 1 CL-PPCRE::COUNTER)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &amp;OPTIONAL), not a (VALUES FIXNUM
;                                                                     &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &amp;OPTIONAL), not a (VALUES FIXNUM
;                                                                     &amp;REST T).
;       etc.

;     (&gt;= (INCF CL-PPCRE::COUNTER) CL-PPCRE::LIMIT)
; --&gt; OR LET &gt; IF 
; ==&gt;
;   (&gt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The second argument is a (OR (DOUBLE-FLOAT (0.0d0)) (SINGLE-FLOAT (0.0))
;                                    (RATIONAL (0))), not a FIXNUM.

;     (CL-PPCRE:DO-SCANS (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                         CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS CL-PPCRE::REGEX
;                         CL-PPCRE::TARGET-STRING NIL :START CL-PPCRE::START :END
;                         CL-PPCRE::END)
;       (UNLESS
;           (AND (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
;                (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST)))
;         (WHEN
;             (AND CL-PPCRE::LIMIT (PLUSP CL-PPCRE::LIMIT) (&gt;= # CL-PPCRE::LIMIT))
;           (RETURN))
;         (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;         (WHEN CL-PPCRE::WITH-REGISTERS-P
;           (LOOP CL-PPCRE::FOR CL-PPCRE::REG-START CL-PPCRE::ACROSS CL-PPCRE::REG-STARTS
;                 CL-PPCRE::FOR CL-PPCRE::REG-END CL-PPCRE::ACROSS CL-PPCRE::REG-ENDS
;                 IF CL-PPCRE::REG-START
;                 DO ...))
;         (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)))
; --&gt; LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --&gt; MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==&gt;
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; --&gt; LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --&gt; MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==&gt;
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR SINGLE-FLOAT DOUBLE-FLOAT RATIONAL
;                                   (COMPLEX SINGLE-FLOAT) (COMPLEX DOUBLE-FLOAT)
;                                   (COMPLEX RATIONAL)), not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR SINGLE-FLOAT DOUBLE-FLOAT RATIONAL
;                                   (COMPLEX SINGLE-FLOAT) (COMPLEX DOUBLE-FLOAT)
;                                   (COMPLEX RATIONAL)), not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (&gt; CL-PPCRE::THIS-END CL-PPCRE::THIS-START)
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a (NOT NULL), not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       etc.

; in: DEFUN STRING-CASE-MODIFIER
;     (CHAR CL-PPCRE::STR (1- CL-PPCRE::FROM))
; --&gt; AREF 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; because:
;   Upgraded element type of array is not known at compile time.

;     (CHAR CL-PPCRE::STR CL-PPCRE::FROM)
; --&gt; AREF 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; because:
;   Upgraded element type of array is not known at compile time.

;     (CHAR CL-PPCRE::STR CL-PPCRE::TO)
; --&gt; AREF 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; because:
;   Upgraded element type of array is not known at compile time.

;     (CHAR CL-PPCRE::STR (1- CL-PPCRE::TO))
; --&gt; AREF 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; because:
;   Upgraded element type of array is not known at compile time.

;     (CHAR CL-PPCRE::STR CL-PPCRE::INDEX)
; --&gt; AREF 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; because:
;   Upgraded element type of array is not known at compile time.

; in: DEFMETHOD BUILD-REPLACEMENT-TEMPLATE (STRING)
;     (POSITION-IF #'CL-PPCRE::DIGIT-CHAR-P CL-PPCRE::REPLACEMENT-STRING :START
;                  CL-PPCRE::MATCH-START :END CL-PPCRE::MATCH-END)
; --&gt; NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==&gt;
;   (SB-KERNEL:%FIND-POSITION-IF
;    (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-C::PREDICATE) SEQUENCE SB-C::FROM-END
;    SB-C::START SB-C::END (SB-KERNEL:EFFECTIVE-FIND-POSITION-KEY SB-C::KEY))
; 
; note: unable to
;   expand inline
; because:
;   upgraded array element type not known at compile time

;     (CHAR CL-PPCRE::REPLACEMENT-STRING (1+ CL-PPCRE::MATCH-START))
; --&gt; AREF 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; because:
;   Upgraded element type of array is not known at compile time.

;     (&lt; CL-PPCRE::FROM CL-PPCRE::MATCH-START)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (1-
;      (PARSE-INTEGER CL-PPCRE::REPLACEMENT-STRING :START CL-PPCRE::PARSE-START
;                     :JUNK-ALLOWED T))
; ==&gt;
;   (-
;    (PARSE-INTEGER CL-PPCRE::REPLACEMENT-STRING :START CL-PPCRE::PARSE-START
;                   :JUNK-ALLOWED T)
;    1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR INTEGER NULL), not a FIXNUM.
;       The result is a (VALUES INTEGER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR INTEGER NULL), not a FIXNUM.
;       The result is a (VALUES INTEGER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.

;     (&lt; CL-PPCRE::TOKEN 0)
; 
; note: forced to do FAST-IF-&lt;-ZERO (cost 9)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.

; in: DEFUN BUILD-REPLACEMENT
;     (ARRAY-DIMENSION CL-PPCRE::REG-STARTS 0)
; 
; note: unable to
;   optimize
; because:
;   The array dimensions are unknown; must call ARRAY-DIMENSION at runtime.

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::MATCH-START
;                        CL-PPCRE::MATCH-END)
; --&gt; BLOCK 
; ==&gt;
;   (MAKE-ARRAY (- CL-PPCRE::END CL-PPCRE::START) :ELEMENT-TYPE
;               (ARRAY-ELEMENT-TYPE SEQUENCE) :DISPLACED-TO SEQUENCE
;               :DISPLACED-INDEX-OFFSET CL-PPCRE::START)
; 
; note: unable to optimize because: ELEMENT-TYPE is not constant.

;     (MAP 'LIST
;          (LAMBDA (CL-PPCRE::REG-START CL-PPCRE::REG-END)
;            (AND CL-PPCRE::REG-START
;                 (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::REG-START
;                                    CL-PPCRE::REG-END)))
;          CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS)
; --&gt; TRULY-THE 
; ==&gt;
;   (SB-KERNEL:%MAP SB-C::RESULT-TYPE-ARG SB-C::FUN #:G50 #:G51)
; 
; note: unable to open code because: can't determine sequence argument type

;     (APPLY CL-PPCRE::TOKEN
;            (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::MATCH-START
;                               CL-PPCRE::MATCH-END)
;            (MAP 'LIST
;                 (LAMBDA (CL-PPCRE::REG-START CL-PPCRE::REG-END)
;                   (AND CL-PPCRE::REG-START
;                        (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING
;                                           CL-PPCRE::REG-START
;                                           CL-PPCRE::REG-END)))
;                 CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS))
; --&gt; MULTIPLE-VALUE-CALL 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL CL-PPCRE::TOKEN)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (MAP 'LIST
;          (LAMBDA (CL-PPCRE::REG-START CL-PPCRE::REG-END)
;            (AND CL-PPCRE::REG-START
;                 (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::REG-START
;                                    CL-PPCRE::REG-END)))
;          CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS)
; --&gt; TRULY-THE 
; ==&gt;
;   (SB-KERNEL:%MAP SB-C::RESULT-TYPE-ARG SB-C::FUN #:G54 #:G55)
; 
; note: unable to open code because: can't determine sequence argument type

;     (FUNCALL CL-PPCRE::TOKEN CL-PPCRE::TARGET-STRING CL-PPCRE::START
;              CL-PPCRE::END CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;              CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS)
; --&gt; SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL CL-PPCRE::TOKEN)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (WITH-OUTPUT-TO-STRING (CL-PPCRE::S NIL :ELEMENT-TYPE CL-PPCRE::ELEMENT-TYPE)
;       (LOOP CL-PPCRE::FOR CL-PPCRE::TOKEN CL-PPCRE::IN CL-PPCRE::REPLACEMENT-TEMPLATE
;             DO (TYPECASE CL-PPCRE::TOKEN
;                  (STRING (WRITE-STRING CL-PPCRE::TOKEN CL-PPCRE::S))
;                  (INTEGER (WHEN # #) (WHEN # #))
;                  (FUNCTION (WRITE-STRING # CL-PPCRE::S))
;                  (SYMBOL (CASE CL-PPCRE::TOKEN # # # # #)))))
; --&gt; SB-INT:DX-LET LET MAKE-STRING THE 
; ==&gt;
;   (MAKE-ARRAY (THE SB-INT:INDEX LENGTH) :ELEMENT-TYPE SB-C::ELEMENT-TYPE)
; 
; note: unable to optimize because: ELEMENT-TYPE is not constant.

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::MATCH-START
;                        CL-PPCRE::MATCH-END)
; --&gt; BLOCK 
; ==&gt;
;   (MAKE-ARRAY (- CL-PPCRE::END CL-PPCRE::START) :ELEMENT-TYPE
;               (ARRAY-ELEMENT-TYPE SEQUENCE) :DISPLACED-TO SEQUENCE
;               :DISPLACED-INDEX-OFFSET CL-PPCRE::START)
; 
; note: unable to optimize because: ELEMENT-TYPE is not constant.

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::REG-START
;                        CL-PPCRE::REG-END)
; --&gt; BLOCK 
; ==&gt;
;   (MAKE-ARRAY (- CL-PPCRE::END CL-PPCRE::START) :ELEMENT-TYPE
;               (ARRAY-ELEMENT-TYPE SEQUENCE) :DISPLACED-TO SEQUENCE
;               :DISPLACED-INDEX-OFFSET CL-PPCRE::START)
; 
; note: unable to optimize because: ELEMENT-TYPE is not constant.
; 
; note: unable to optimize because: ELEMENT-TYPE is not constant.

;     (WITH-OUTPUT-TO-STRING (CL-PPCRE::S NIL :ELEMENT-TYPE CL-PPCRE::ELEMENT-TYPE)
;       (LOOP CL-PPCRE::FOR CL-PPCRE::TOKEN CL-PPCRE::IN CL-PPCRE::REPLACEMENT-TEMPLATE
;             DO (TYPECASE CL-PPCRE::TOKEN
;                  (STRING (WRITE-STRING CL-PPCRE::TOKEN CL-PPCRE::S))
;                  (INTEGER (WHEN # #) (WHEN # #))
;                  (FUNCTION (WRITE-STRING # CL-PPCRE::S))
;                  (SYMBOL (CASE CL-PPCRE::TOKEN # # # # #)))))
; --&gt; SB-INT:DX-LET LET MAKE-STRING THE MULTIPLE-VALUE-BIND LET VALUES PROG1 
; --&gt; LET PROGN 
; ==&gt;
;   #:G61
; 
; note: could not stack allocate #:G60 in:
;        (WITH-OUTPUT-TO-STRING (S NIL :ELEMENT-TYPE ELEMENT-TYPE)
;          (LOOP FOR TOKEN IN REPLACEMENT-TEMPLATE
;                DO (TYPECASE TOKEN
;                     (STRING (WRITE-STRING TOKEN S))
;                     (INTEGER
;                      (WHEN (&gt;= TOKEN REG-BOUND)
;                        (SIGNAL-INVOCATION-ERROR
;                         &quot;Reference to non-existent register ~A in replacement string.&quot;
;                         (1+ TOKEN)))
;                      (WHEN (SVREF REG-STARTS TOKEN)
;                        (WRITE-STRING TARGET-STRING S :START
;                                      (SVREF REG-STARTS TOKEN) :END
;                                      (SVREF REG-ENDS TOKEN))))
;                     (FUNCTION
;                      (WRITE-STRING
;                       (COND
;                        (SIMPLE-CALLS
;                         (APPLY TOKEN
;                                (NSUBSEQ TARGET-STRING MATCH-START MATCH-END)
;                                (MAP 'LIST
;                                     (LAMBDA (REG-START REG-END)
;                                       (AND REG-START
;                                            (NSUBSEQ TARGET-STRING REG-START
;                                                     REG-END)))
;                                     REG-STARTS REG-ENDS)))
;                        (T
;                         (FUNCALL TOKEN TARGET-STRING START END MATCH-START
;                                  MATCH-END REG-STARTS REG-ENDS)))
;                       S))
;                     (SYMBOL
;                      (CASE TOKEN
;                        ((:BACKSLASH) (WRITE-CHAR #\\ S))
;                        ((:MATCH)
;                         (WRITE-STRING TARGET-STRING S :START MATCH-START :END
;                                       MATCH-END))
;                        ((:BEFORE-MATCH)
;                         (WRITE-STRING TARGET-STRING S :START START :END
;                                       MATCH-START))
;                        ((:AFTER-MATCH)
;                         (WRITE-STRING TARGET-STRING S :START MATCH-END :END
;                                       END))
;                        (OTHERWISE
;                         (WRITE-STRING
;                          (COND
;                           (SIMPLE-CALLS
;                            (APPLY TOKEN
;                                   (NSUBSEQ TARGET-STRING MATCH-START MATCH-END)
;                                   (MAP 'LIST
;                                        (LAMBDA (REG-START REG-END)
;                                          (AND REG-START
;                                               (NSUBSEQ TARGET-STRING REG-START
;                                                        REG-END)))
;                                        REG-STARTS REG-ENDS)))
;                           (T
;                            (FUNCALL TOKEN TARGET-STRING START END MATCH-START
;                                     MATCH-END REG-STARTS REG-ENDS)))
;                          S)))))))

;     (&gt;= CL-PPCRE::TOKEN CL-PPCRE::REG-BOUND)
; --&gt; IF 
; ==&gt;
;   (&lt; SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-&lt; (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.

;     (1+ CL-PPCRE::TOKEN)
; ==&gt;
;   (+ CL-PPCRE::TOKEN 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &amp;OPTIONAL), not a (VALUES FIXNUM
;                                                                     &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &amp;OPTIONAL), not a (VALUES FIXNUM
;                                                                     &amp;REST T).
;       etc.

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::MATCH-START
;                        CL-PPCRE::MATCH-END)
; --&gt; BLOCK MAKE-ARRAY 
; ==&gt;
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::REG-START
;                        CL-PPCRE::REG-END)
; --&gt; BLOCK MAKE-ARRAY 
; ==&gt;
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a (NOT NULL), not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a (NOT NULL), not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; in: DEFUN REPLACE-AUX
;     (FUNCALL
;      (CL-PPCRE::STRING-CASE-MODIFIER CL-PPCRE::TARGET-STRING CL-PPCRE::FROM
;       CL-PPCRE::TO CL-PPCRE::START CL-PPCRE::END)
;      CL-PPCRE::CURR-REPLACEMENT)
; --&gt; SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL
;    (CL-PPCRE::STRING-CASE-MODIFIER CL-PPCRE::TARGET-STRING CL-PPCRE::FROM
;     CL-PPCRE::TO CL-PPCRE::START CL-PPCRE::END))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (WITH-OUTPUT-TO-STRING (CL-PPCRE::S NIL :ELEMENT-TYPE CL-PPCRE::ELEMENT-TYPE)
;       (LOOP CL-PPCRE::FOR (CL-PPCRE::FROM CL-PPCRE::TO) CL-PPCRE::ON (APPEND
;                                                                       (LIST
;                                                                        CL-PPCRE::START)
;                                                                       CL-PPCRE::POS-LIST
;                                                                       (LIST
;                                                                        CL-PPCRE::END))
;             CL-PPCRE::FOR REPLACE = NIL CL-PPCRE::THEN (AND (NOT REPLACE)
;                                                             CL-PPCRE::TO)
;             CL-PPCRE::FOR ...))
; --&gt; SB-INT:DX-LET LET MAKE-STRING THE 
; ==&gt;
;   (MAKE-ARRAY (THE SB-INT:INDEX LENGTH) :ELEMENT-TYPE SB-C::ELEMENT-TYPE)
; 
; note: unable to optimize because: ELEMENT-TYPE is not constant.

; --&gt; SB-INT:DX-LET LET MAKE-STRING THE MULTIPLE-VALUE-BIND LET VALUES PROG1 
; --&gt; LET PROGN 
; ==&gt;
;   #:G31
; 
; note: could not stack allocate #:G30 in:
;        (WITH-OUTPUT-TO-STRING (S NIL :ELEMENT-TYPE ELEMENT-TYPE)
;          (LOOP FOR (FROM TO) ON (APPEND (LIST START) POS-LIST (LIST END))
;                FOR REPLACE = NIL THEN (AND (NOT REPLACE) TO)
;                FOR REG-STARTS = (IF REPLACE
;                                     (POP REG-LIST)
;                                     NIL)
;                FOR REG-ENDS = (IF REPLACE
;                                   (POP REG-LIST)
;                                   NIL)
;                FOR CURR-REPLACEMENT = (IF REPLACE
;                                           (BUILD-REPLACEMENT
;                                            REPLACEMENT-TEMPLATE TARGET-STRING
;                                            START END FROM TO REG-STARTS
;                                            REG-ENDS SIMPLE-CALLS ELEMENT-TYPE)
;                                           NIL)
;                WHILE TO
;                IF REPLACE
;                DO (WRITE-STRING
;                    (IF PRESERVE-CASE
;                        (FUNCALL
;                         (STRING-CASE-MODIFIER TARGET-STRING FROM TO START END)
;                         CURR-REPLACEMENT)
;                        CURR-REPLACEMENT)
;                    S) ELSE
;                DO (WRITE-STRING TARGET-STRING S :START FROM :END TO)))

; in: DEFUN REGEX-REPLACE
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (SUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::START CL-PPCRE::END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

; in: DEFUN REGEX-REPLACE-ALL
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-SCANS (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                         CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS CL-PPCRE::REGEX
;                         CL-PPCRE::TARGET-STRING NIL :START CL-PPCRE::START :END
;                         CL-PPCRE::END)
;       (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;       (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)
;       (PUSH CL-PPCRE::REG-STARTS CL-PPCRE::REG-LIST)
;       (PUSH CL-PPCRE::REG-ENDS CL-PPCRE::REG-LIST))
; --&gt; LET BLOCK LET* OR LET IF 
; ==&gt;
;   (LENGTH #:TARGET-STRING1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --&gt; LET BLOCK LET* SETQ THE CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND 
; --&gt; IF THE COERCE THE IF REPLACE MAKE-ARRAY 
; ==&gt;
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR CONS NULL
;                               (AND (NOT (SIMPLE-ARRAY CHARACTER (*)))
;                                    (NOT (SIMPLE-ARRAY NIL (*)))
;                                    (NOT SIMPLE-BASE-STRING) VECTOR)
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

; --&gt; LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --&gt; MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==&gt;
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --&gt; LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --&gt; MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==&gt;
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a (OR SINGLE-FLOAT DOUBLE-FLOAT RATIONAL
;                               (COMPLEX SINGLE-FLOAT) (COMPLEX DOUBLE-FLOAT)
;                               (COMPLEX RATIONAL)), not a RATIONAL.

;     (SUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::START CL-PPCRE::END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

;     (CL-PPCRE:DO-SCANS (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                         CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS CL-PPCRE::REGEX
;                         CL-PPCRE::TARGET-STRING NIL :START CL-PPCRE::START :END
;                         CL-PPCRE::END)
;       (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;       (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)
;       (PUSH CL-PPCRE::REG-STARTS CL-PPCRE::REG-LIST)
;       (PUSH CL-PPCRE::REG-ENDS CL-PPCRE::REG-LIST))
; --&gt; LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --&gt; MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==&gt;
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a DOUBLE-FLOAT.
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a (NOT NULL), not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; --&gt; LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --&gt; MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==&gt;
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR SINGLE-FLOAT DOUBLE-FLOAT RATIONAL
;                                   (COMPLEX SINGLE-FLOAT) (COMPLEX DOUBLE-FLOAT)
;                                   (COMPLEX RATIONAL)), not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR SINGLE-FLOAT DOUBLE-FLOAT RATIONAL
;                                   (COMPLEX SINGLE-FLOAT) (COMPLEX DOUBLE-FLOAT)
;                                   (COMPLEX RATIONAL)), not a FIXNUM.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
;       etc.


; wrote /home/dunham/.cache/common-lisp/sbcl-2.0.10-linux-x64/home/dunham/common-lisp/cl-ppcre/api-tmpY2ML9CFA.fasl
; compilation finished in 0:00:00.280

; processing (DEFINE-ALIEN-ROUTINE SYSCONF ...)
; processing (USE-PACKAGE :SB-THREAD)
; processing (DEFCONSTANT +REGEX-LIST+ ...)
; processing (DEFCONSTANT +ALTERNATIVES+ ...)
; processing (DEFCONSTANT +CPU-COUNT+ ...)
; processing (DEFVAR *MUTEX* ...)
; processing (DEFVAR *AUX-MUTEX* ...)
; processing (DEFMACRO BG ...)
; processing (DEFMACRO JOIN-ALL ...)
; processing (DEFUN READ-ALL ...)
; processing (DEFUN LENGTH-TO-REPLACE ...)
; processing (DEFUN REPLACE-AUX ...)
; file: /home/dunham/all-benchmarksgame/2000-benchmarksgame/bench/regexredux/regexredux.sbcl-4.sbcl
; in: DEFUN REPLACE-AUX
;     (LOOP WITH (I J) OF-TYPE FIXNUM = (LIST RESULT-START TARGET-START)
;           WITH MMATCH = (IF (&gt; MATCH-BEGIN MATCH-END)
;                             MATCH
;                             (SUBSEQ MATCH MATCH-BEGIN MATCH-END))
;           FOR ...)
; --&gt; BLOCK LET SB-LOOP::LOOP-DESTRUCTURING-BIND DESTRUCTURING-BIND 
; --&gt; SB-INT:BINDING* LET* IF 
; ==&gt;
;   NIL
; 
; caught STYLE-WARNING:
;   The binding of I is not a FIXNUM:
;    NIL
;   See also:
;     The SBCL Manual, Node &quot;Handling of Types&quot;
; 
; caught STYLE-WARNING:
;   The binding of J is not a FIXNUM:
;    NIL
;   See also:
;     The SBCL Manual, Node &quot;Handling of Types&quot;

; processing (DEFUN PARTS ...)
; file: /home/dunham/all-benchmarksgame/2000-benchmarksgame/bench/regexredux/regexredux.sbcl-4.sbcl
; in: DEFUN PARTS
;     (LOOP WITH (STEP
;                 REST) OF-TYPE FIXNUM = (MULTIPLE-VALUE-LIST
;                                         (FLOOR LEN PARTS-NUM))
;           WITH I OF-TYPE FIXNUM = ...)
; --&gt; BLOCK LET SB-LOOP::LOOP-DESTRUCTURING-BIND DESTRUCTURING-BIND 
; --&gt; SB-INT:BINDING* LET* IF 
; ==&gt;
;   NIL
; 
; caught STYLE-WARNING:
;   This is not a FIXNUM:
;    NIL
;   See also:
;     The SBCL Manual, Node &quot;Handling of Types&quot;
; 
; caught STYLE-WARNING:
;   The binding of REST is not a FIXNUM:
;    NIL
;   See also:
;     The SBCL Manual, Node &quot;Handling of Types&quot;

; processing (DEFUN REPLACE-ALL ...)
; processing (DEFUN MAIN ...); 
; compilation unit finished
;   caught 1 WARNING condition
;   caught 4 STYLE-WARNING conditions
;   printed 707 notes


; wrote /home/dunham/all-benchmarksgame/benchmarksgame_i53330/regexredux/tmp/regexredux.sbcl-4.fasl
; compilation finished in 0:00:02.380
### START regexredux.sbcl-4.sbcl_run
(main) (quit)
### END regexredux.sbcl-4.sbcl_run


4.86s to complete and log all make actions

COMMAND LINE:
/usr/local/bin/sbcl  --noinform --core sbcl.core --userinit /dev/null --load regexredux.sbcl-4.sbcl_run 0 &lt; regexredux-input5000000.txt

PROGRAM OUTPUT:
agggtaaa|tttaccct 356
[cgt]gggtaaa|tttaccc[acg] 1250
a[act]ggtaaa|tttacc[agt]t 4252
ag[act]gtaaa|tttac[agt]ct 2894
agg[act]taaa|ttta[agt]cct 5435
aggg[acg]aaa|ttt[cgt]ccct 1537
agggt[cgt]aa|tt[acg]accct 1431
agggta[cgt]a|t[acg]taccct 1608
agggtaa[cgt]|[acg]ttaccct 2178

50833411
50000000
27388361
    </pre>
  </section>
</article>
<footer>
  <nav>
    <ul>
      <li><a href="https://salsa.debian.org/benchmarksgame-team/benchmarksgame/blob/master/CONTRIBUTING.md#contribute-source-code-for-measurement"><span>Contribute your own program</span></a>
      <li><a href="../license.html"><span>3-Clause BSD License</span></a>
    </ul>
  </nav>
</footer>

