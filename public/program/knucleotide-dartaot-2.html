<!DOCTYPE html>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="robots" content="noindex,follow,noarchive">

<title>k-nucleotide Dart aot&nbsp;#2 program | Computer Language Benchmarks Game </title>
<style><!--
a{color:black;text-decoration:none}article{padding:0 0 2.9em}article,div,footer,header{margin:auto;width:92%}body{font:100% Droid Sans, Ubuntu, Verdana, sans-serif;margin:0;-webkit-text-size-adjust:100%}h3, h1, h2, li a{font-family:Ubuntu Mono,Consolas,Menlo,monospace}div,footer,header{max-width:31em}footer{padding:2.6em 0 0}h3{font-size:1.4em;font-weight:bold;margin:0;padding: .4em}h3, h3 a{color:white;background-color:#dd4814}h3 small{font-size:0.64em}h1,h2{margin:1.5em 0 0}h1{font-size:1.4em;font-weight:normal}h2{font-size:1.2em}li{list-style-type:none;vertical-align:top}li a{display:block;font-size:1.2em;margin: .5em .5em 0;padding: .5em .5em .3em}ul{clear:left;margin:-0.3em 0 1.5em;padding-left:0;text-align:center}p{color:#333;line-height:1.4;margin: .3em 0 0}p a, a span{border-bottom: .1em solid #333;padding-bottom: .1em}.com,.slc{color:#888}.kwa{color:#066}.kwb{color:#900}.kwc{color:#050}.kwa,.kwb,.kwc{font-weight:bold}.dstr,.str,.sym,.num{color:#930}pre{color:#222;font-size:1em;overflow-wrap:break-word;white-space:pre-wrap;word-wrap:break-word}@media only screen and (min-width: 60em){article,footer,header{font-size:1.25em}}
--></style>
<link rel="shortcut icon" href="./favicon.ico">
<header>
  <h3><a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/">The&nbsp;<small>Computer&nbsp;Language</small><br>Benchmarks&nbsp;Game</a></h3>
</header>
<article>
  <div>
    <h1>k-nucleotide Dart aot&nbsp;#2 program</h1>
    <aside>
      <p><a href="../description/knucleotide.html#knucleotide">description</a>
    </aside>
  </div>
  <section>
    </div>
      <h2>source code</h2>
    </div>
    <pre>
/**
 * The Computer Language Benchmarks Game
 *
 * https://salsa.debian.org/benchmarksgame-team/benchmarksgame/
 *
 * Contributed by Dwayne Slater
 * Based on a Java implementation by James McIlree and Tagir Valeev
 */

library knucleotide;

import &apos;dart:async&apos;;
import &apos;dart:collection&apos;;
import &apos;dart:convert&apos;;
import &apos;dart:io&apos;;
import &apos;dart:isolate&apos;;

const codes = const [-1, 0, -1, 1, 3, -1, -1, 2];
const nucleotides = &apos;ACGT&apos;;

/**
 * Contains a map from keys to occurrence count.
 */
class Result {
  final Map&lt;int, int&gt; map = {};
  Result();

  &#64;override
  String toString() =&gt; &quot;$map&quot;;
}

/**
 * A pair of keys to counts.
 */
class KeyPair {
  final String key;
  final int count;
  KeyPair(this.key, this.count);
}

/**
 * Converts a slice of the sequence into a key.
 */
int getKey(List&lt;int&gt; arr, int offset, int length) {
  int key = 0;
  int lastOffset = offset + length;
  for (int i = offset; i &lt; lastOffset; i++) {
    key = (key &lt;&lt; 2) + arr[i];
  }
  return key;
}

/**
 * Creates a map of all the times any key occurs in the sequence.
 */
Result createFragmentMap(List&lt;int&gt; sequence, int offset, int fragmentLength) {
  var res = new Result();
  int lastIndex = sequence.length-fragmentLength+1;
  for (int index = offset; index &lt; lastIndex; index += fragmentLength) {
    var key = getKey(sequence, index, fragmentLength);
    res.map[key] = (res.map[key] ?? 0)+1;
  }
  return res;
}

/**
 * Combines two [Result]s together.
 */
Result sumTwoMaps(Result map1, Result map2) {
  map2.map.forEach((key, value) =&gt; map1.map[key] += value);
  return map1;
}

/**
 * Converts a key to a string.
 */
String keyToString(int key, int length) {
  var res = new List&lt;String&gt;(length);
  for (int i = 0; i &lt; length; i++) {
    res[length - i - 1] = nucleotides[key &amp; 0x3];
    key &gt;&gt;= 2;
  }
  return res.join();
}

/**
 * Write out the frequencies for each key that appears in the given [Result].
 */
String writeFrequencies(double totalCount, int keyLength, Result frequencies) {
  var freq = new List&lt;KeyPair&gt;(frequencies.map.length);
  var i = 0;
  frequencies.map.forEach((key, cnt) =&gt; freq[i++] = new KeyPair(keyToString(key, keyLength), cnt));
  freq.sort((a, b) =&gt; b.count.compareTo(a.count));
  var sb = new StringBuffer();
  freq.forEach((entry) {
    sb.write(&quot;${entry.key} ${(entry.count * 100.0/totalCount).toStringAsFixed(3)}\n&quot;);
  });
  return (sb..write(&quot;\n&quot;)).toString();
}

/**
 * Converts a character list into a list of codes.
 */
List&lt;int&gt; toCodes(List&lt;int&gt; sequence) {
  var l = sequence.length;
  var result = new List&lt;int&gt;(l);
  for (int i = 0; i &lt; l; i++) {
    result[i] = codes[sequence[i] &amp; 0x7];
  }
  return result;
}

/**
 * Write out the occurrences of the given nucleotideFragment in the list of
 * pending results.
 */
Future&lt;String&gt; writeCount(List&lt;Future&lt;Result&gt;&gt; futureResults, String nucleotideFragment) async {
  var key = toCodes(nucleotideFragment.codeUnits);
  var k = getKey(key, 0, key.length);
  var count = 0;
  await Future.wait(futureResults.map((future) {
    return future.then((f) {
      count += f.map[k] ?? 0;
    });
  }).toList());
  return &quot;$count\t$nucleotideFragment\n&quot;;
}

/**
 * Reads sequence data from stdin.
 */
FutureOr&lt;List&lt;int&gt;&gt; read({bool sync: false}) async {
  if (!sync) {
    // The old Dart k-nucleotide benchmark used stdin.readLineSync, which is
    // way slower than doing async stream transforms.
    var three = false;
    var builder = new BytesBuilder(copy: false);
    StreamSubscription&lt;List&lt;int&gt;&gt; sub;
    sub = stdin
      .transform(const Latin1Decoder())
      .transform(const LineSplitter())
      .listen((line) {
        if (three) {
          if (line[0] != &apos;&gt;&apos;) {
            builder.add(line.codeUnits);
          } else {
            sub.cancel();
          }
        } else if (line.startsWith(&apos;&gt;THREE&apos;)) {
          three = true;
        }
      });
    await sub.asFuture();
    var bytes = builder.takeBytes();
    return toCodes(bytes);
  } else {
    var encoding = Encoding.getByName(&quot;ISO_8859-1:1987&quot;);
    String line;
    while (stdin.readLineSync().substring(0, 6) != &apos;&gt;THREE&apos;);

    var builder = new BytesBuilder(copy: false);
    while ((line = stdin.readLineSync(encoding: encoding)) != null &amp;&amp; line[0] != &apos;&gt;&apos;) {
      builder.add(line.codeUnits);
    }

    var bytes = builder.takeBytes();
    return toCodes(bytes);
  }
}

/**
 * An object that runs on an Isolate.
 */
abstract class Task {
  run();
}

/**
 * The sequence data for the current Isolate.
 */
List&lt;int&gt; isolateSequence;

/**
 * Initializes the per-isolate sequence data.
 */
class InitIsolateSequenceTask extends Task {
  final String sequence;

  InitIsolateSequenceTask(this.sequence);

  void run() {
    isolateSequence = sequence.codeUnits;
  }
}

/**
 * Creates a FragmentMap using the sequence data and the given parameters.
 */
class CreateFragmentMapTask extends Task {
  final int index, fragmentLength;
  CreateFragmentMapTask(this.index, this.fragmentLength);

  run() =&gt; createFragmentMap(isolateSequence, index, fragmentLength);
}

/**
 * Handles the submission and completion of tasks sent to an Isolate.
 */
class IsolateHandler {
  final Isolate _isolate;
  final SendPort _taskport;
  final RawReceivePort _port;
  final Queue&lt;Completer&gt; _completers = new Queue&lt;Completer&gt;();
  IsolateHandler._(this._isolate, this._taskport, this._port);

  /**
   * Creates an IsolateHandler.
   */
  static Future&lt;IsolateHandler&gt; create() async {
    IsolateHandler handler;
    var completer = new Completer&lt;SendPort&gt;.sync();
    var port = new RawReceivePort((data) {
      if (!completer.isCompleted) {
        completer.complete(data);
      } else {
        handler._finish(data);
      }
    });
    var isolate = await Isolate.spawn(_runner, port.sendPort);
    var taskport = await completer.future;
    return handler = new IsolateHandler._(isolate, taskport, port);
  }

  /**
   * Main &quot;loop&quot; of the task running Isolate.
   */
  static void _runner(SendPort inport) {
    var port = new RawReceivePort((Task task) {
      inport.send(task.run());
    });
    inport.send(port.sendPort);
  }

  void _finish(data) {
    _completers.removeFirst().complete(data);
  }

  /**
   * Schedules a task to the underlying Isolate.
   */
  Future&lt;T&gt; schedule&lt;T&gt;(Task task) {
    var c = new Completer&lt;T&gt;.sync();
    _taskport.send(task);
    _completers.add(c);
    return c.future;
  }

  /**
   * Gets the current load on the Isolate.
   */
  int get weight =&gt; _completers.length;

  /**
   * Closes the IsolateHandler and cleans up associated resources.
   */
  void close() {
    _isolate.kill();
    _port.close();
  }
}

/**
 * Manages multiple [IsolateHandler] objects.
 * Allows tasks to be scheduled on the least loaded Isolate.
 */
class IsolateExecutor {
  final List&lt;IsolateHandler&gt; _handlers;

  IsolateExecutor._(this._handlers);

  /**
   * Create an IsolateExecutor. By default this creates an isolate for each
   * core of the current running system.
   */
  static Future&lt;IsolateExecutor&gt; create({int n}) async {
    n ??= Platform.numberOfProcessors;
    var handlers = await Future.wait(new Iterable.generate(n, (_) =&gt; IsolateHandler.create()));
    return new IsolateExecutor._(handlers);
  }

  /**
   * Schedules a task on ALL of the IsolateHandlers.
   */
  Future&lt;List&lt;T&gt;&gt; scheduleAll&lt;T&gt;(Task task) {
    var futures = _handlers.map((handler) =&gt; handler.schedule(task)).toList();
    return Future.wait(futures);
  }

  /**
   * Schedules a task on the least loaded IsolateHandler.
   */
  Future&lt;T&gt; schedule&lt;T&gt;(Task task) {
    var leastLoad = _handlers.first;
    var leastLoadScore = leastLoad.weight;
    for (int i=1; i&lt;_handlers.length; i++) {
      var handler = _handlers[i];
      var score = handler.weight;
      if (score &lt; leastLoadScore) {
        leastLoad = handler;
      }
    }
    return leastLoad.schedule(task);
  }

  /**
   * Closes all IsolateHandlers.
   */
  void close() {
    _handlers.forEach((h) =&gt; h.close());
  }
}

/**
 * Dispatches fragment map creation to an isolate,
 */
List&lt;Future&lt;Result&gt;&gt; dispatchFragmentTasks(IsolateExecutor executor, int fragmentLength) {
  List&lt;Future&lt;Result&gt;&gt; tasks = [];
  for (int index = 0; index &lt; fragmentLength; index++) {
    tasks.add(executor.schedule(new CreateFragmentMapTask(index, fragmentLength)));
  }
  return tasks;
}

main() async {
  // Start creating the executor while we wait on IO to finish
  var executorFuture = IsolateExecutor.create();
  // Read the data from stdin
  var sequence = await read();
  // Wait on the executor to start if it hasn&apos;t finished yet
  var executor = await executorFuture;

  // We start by intializing all the executor isolates with the sequence we read
  // Unfortunately, Dart has to copy all the data when doing this
  // To optimize this a bit, we can send it as a String :P (Saves about 20 seconds from my testing)
  executor.scheduleAll(new InitIsolateSequenceTask(new String.fromCharCodes(sequence)));

  var futureBuffer = &lt;Future&lt;String&gt;&gt;[
    // Dispatch a task to get the frequencies with a fragment length of 1
    dispatchFragmentTasks(executor, 1)[0]
      .then((result) =&gt; writeFrequencies(sequence.length.toDouble(), 1, result)),
    // Dispatch a task to get the frequencies with a fragment length of 2
    Future.wait(dispatchFragmentTasks(executor, 2))
      .then((results) =&gt; writeFrequencies((sequence.length-1).toDouble(), 2, sumTwoMaps(results[0], results[1]))),
  ];
  // Dispatch tasks for each of the nucleotideFragments
  const [&quot;GGT&quot;, &quot;GGTA&quot;, &quot;GGTATT&quot;, &quot;GGTATTTTAATT&quot;, &quot;GGTATTTTAATTTATAGT&quot;].forEach((nucleotideFragment) {
    futureBuffer.add(writeCount(dispatchFragmentTasks(executor, nucleotideFragment.length), nucleotideFragment));
  });

  // Wait for everything to finish, then join the resulting output together
  stdout.write((await Future.wait(futureBuffer)).join());
  executor.close();
}
    </pre>
  </section>
  <section>
    <h2 id="log">notes, command-line, and program output</h2>
    <pre>
NOTES:
64-bit Ubuntu quad core
Dart VM version: 2.4.0 (Wed Jun 19 11:53:45 2019 +0200) on "linux_x64"



Sat, 20 Jul 2019 17:18:31 GMT

MAKE:
/opt/src/dartsdk-linux-x64-release/dart-sdk/bin/dartanalyzer knucleotide.dartaot-2.dartaot
Analyzing knucleotide.dartaot-2.dartaot...
  error • A value of type 'StreamSubscription&lt;String&gt;' can't be assigned to a variable of type 'StreamSubscription&lt;List&lt;int&gt;&gt;' at knucleotide.dartaot-2.dartaot:139:11 • invalid_assignment
  error • The argument type 'List&lt;Future&gt;' can't be assigned to the parameter type 'Iterable&lt;Future&lt;T&gt;&gt;' at knucleotide.dartaot-2.dartaot:296:24 • argument_type_not_assignable
2 errors found.
make: [/home/dunham/8000-benchmarksgame/nanobench/makefiles/u64q.programs.Makefile:712: knucleotide.dartaot-2.dartaot_run] Error 3 (ignored)
/opt/src/dartsdk-linux-x64-release/dart-sdk/bin/dart2aot knucleotide.dartaot-2.dartaot knucleotide.dartaot-2.aot
knucleotide.dartaot-2.dartaot:142:8: Error: A value of type 'StreamSubscription&lt;String&gt;' can't be assigned to a variable of type 'StreamSubscription&lt;List&lt;int&gt;&gt;'.
 - 'StreamSubscription' is from 'dart:async'.
 - 'List' is from 'dart:core'.
Try changing the type of the left hand side, or casting the right hand side to 'StreamSubscription&lt;List&lt;int&gt;&gt;'.
      .listen((line) {
       ^
knucleotide.dartaot-2.dartaot:296:24: Error: The argument type 'List&lt;Future&lt;dynamic&gt;&gt;' can't be assigned to the parameter type 'Iterable&lt;Future&lt;T&gt;&gt;'.
 - 'List' is from 'dart:core'.
 - 'Future' is from 'dart:async'.
 - 'Iterable' is from 'dart:core'.
Try changing the type of the parameter, or casting the argument to 'Iterable&lt;Future&lt;T&gt;&gt;'.
    return Future.wait(futures);
                       ^
make: [/home/dunham/8000-benchmarksgame/nanobench/makefiles/u64q.programs.Makefile:713: knucleotide.dartaot-2.dartaot_run] Error 254 (ignored)

8.46s to complete and log all make actions

COMMAND LINE:
/opt/src/dartsdk-linux-x64-release/dart-sdk/bin/dartaotruntime knucleotide.dartaot-2.aot 0 &lt; knucleotide-input250000.txt

PROGRAM FAILED 


PROGRAM OUTPUT:

VM initialization failed: Invalid vm isolate snapshot seen
    </pre>
  </section>
</article>
<footer>
  <nav>
    <ul>
      <li><a href="../license.html"><span>3-Clause BSD License</span></a>
    </ul>
  </nav>
</footer>

