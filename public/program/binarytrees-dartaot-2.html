<!DOCTYPE html>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="robots" content="noindex,follow,noarchive">

<title>binary-trees Dart aot&nbsp;#2 program | Computer Language Benchmarks Game </title>
<style><!--
a{color:black;text-decoration:none}article{padding:0 0 2.9em}article,div,footer,header{margin:auto;width:92%}body{font:100% Droid Sans, Ubuntu, Verdana, sans-serif;margin:0;-webkit-text-size-adjust:100%}h3, h1, h2, li a{font-family:Ubuntu Mono,Consolas,Menlo,monospace}div,footer,header{max-width:31em}footer{padding:2.6em 0 0}h3{font-size:1.4em;font-weight:bold;margin:0;padding: .4em}h3, h3 a{color:white;background-color:#dd4814}h3 small{font-size:0.64em}h1,h2{margin:1.5em 0 0}h1{font-size:1.4em;font-weight:normal}h2{font-size:1.2em}li{list-style-type:none;vertical-align:top}li a{display:block;font-size:1.2em;margin: .5em .5em 0;padding: .5em .5em .3em}ul{clear:left;margin:-0.3em 0 1.5em;padding-left:0;text-align:center}p{color:#333;line-height:1.4;margin: .3em 0 0}p a, a span{border-bottom: .1em solid #333;padding-bottom: .1em}.com,.slc{color:#888}.kwa{color:#066}.kwb{color:#900}.kwc{color:#050}.kwa,.kwb,.kwc{font-weight:bold}.dstr,.str,.sym,.num{color:#930}pre{color:#222;font-size:1em;overflow-wrap:break-word;white-space:pre-wrap;word-wrap:break-word}@media only screen and (min-width: 60em){article,footer,header{font-size:1.25em}}
--></style>
<link rel="shortcut icon" href="./favicon.ico">
<header>
  <h3><a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/">The&nbsp;<small>Computer&nbsp;Language</small><br>Benchmarks&nbsp;Game</a></h3>
</header>
<article>
  <div>
    <h1>binary-trees Dart aot&nbsp;#2 program</h1>
    <aside>
      <p><a href="../description/binarytrees.html#binarytrees">description</a>
    </aside>
  </div>
  <section>
    </div>
      <h2>source code</h2>
    </div>
    <pre>
/* The Computer Language Benchmarks game
   https://salsa.debian.org/benchmarksgame-team/benchmarksgame/

   Contributed by Jos Hirth, transliterated from Jarkko Miettinen&apos;s Java program
   Optimized and parallelized by by Dwayne Slater
   *reset*
*/

import &apos;dart:async&apos;;
import &apos;dart:io&apos;;
import &apos;dart:isolate&apos;;

const int minDepth = 4;

/// Number of workers to startup. A number below the number of processors on the
/// current system works best.
const int workerCount = 4;

/// Whether to output debug information for workers.
const bool workerDebug = false;

class Worker {
  final SendPort workPort;
  bool ready = true;
  Capability workItem;

  Worker(this.workPort);

  void submitWork(List work) {
    workPort.send(work);
    ready = false;
    workItem = work[2];
  }
}

void worker(SendPort managerPort) {
  // Make worker port
  final worker = RawReceivePort((message) {
    // `message` is a work item
    final List workItem = message;

    // Process the work item
    final int iterations = workItem[1];
    int check = 0;
    for (int i = 1; i &lt;= iterations; i++) {
      check += TreeNode.itemCheck(TreeNode.bottomUpTree(workItem[0]));
    }

    managerPort.send([check, workItem[2]]);
  });

  managerPort.send(worker.sendPort);
}

/// Manages distributing work to available workers
class Manager {
  final RawReceivePort managerPort;
  final List&lt;Worker&gt; workers;
  final List&lt;List&gt; queuedWork = [];
  final Map&lt;Capability, Completer&lt;int&gt;&gt; workCompleters = {};

  Manager(this.managerPort, this.workers) {
    managerPort.handler = (message) {
      if (message is List) {
        final cap = message[1];
        workCompleters.remove(cap).complete(message[0]);
        for (int i=0; i&lt;workers.length; i++) {
          final worker = workers[i];
          if (worker.workItem == cap) {
            if (queuedWork.isNotEmpty) {
              if (workerDebug) print(&quot;Submitting more work to $i&quot;);
              worker.submitWork(queuedWork.removeLast());
            } else {
              if (workerDebug) print(&quot;Worker $i idle&quot;);
              worker.ready = true;
            }
            break;
          }
        }
      }
    };
  }

  Future&lt;int&gt; enqueue(int depth, int iterations) {
    final cap = Capability();
    final work = [depth, iterations, cap];
    final completer = Completer&lt;int&gt;.sync();
    workCompleters[cap] = completer;

    // Try submit work item to a ready worker
    for (int i=0; i&lt;workers.length; i++) {
      final worker = workers[i];
      if (worker.ready) {
        if (workerDebug) print(&quot;Dispatched work to worker $i&quot;);
        worker.submitWork(work);
        return completer.future;
      }
    }

    // Otherwise, throw into work queue for work stealing
    if (workerDebug) print(&quot;Work added to queue&quot;);
    queuedWork.add(work);
    return completer.future;
  }

  static Future&lt;Manager&gt; init(int workerCount) async {
    // Spawn and wait for all workers to come online
    final sw = Stopwatch()..start();
    final workers = &lt;Worker&gt;[];
    final completer = Completer&lt;void&gt;();
    final managerPort = RawReceivePort((workerPort) {
      if (workerDebug) print(&quot;[${sw.elapsedMilliseconds}] Worker online&quot;);
      workers.add(Worker(workerPort));
      if (workers.length == workerCount) {
        completer.complete();
      }
    });
    for (int i=0; i&lt;workerCount; i++) {
      Isolate.spawn(worker, managerPort.sendPort);
    }
    await completer.future;
    return Manager(managerPort, workers);
  }
}

Future&lt;void&gt; main(List&lt;String&gt; args) async {
  int n = args.length &gt; 0 ? int.parse(args[0]) : 0;

  final sw = Stopwatch()..start();

  // Start up the workers, then dispatch work to them
  final futureManager = Manager.init(workerCount);
  final manager = await futureManager;

  int maxDepth = (minDepth + 2 &gt; n) ? minDepth + 2 : n;

  List&lt;Future&lt;int&gt;&gt; workFuture = [];
  for (int depth = minDepth; depth &lt;= maxDepth; depth += 2) {
    int iterations = 1 &lt;&lt; (maxDepth - depth + minDepth);
    workFuture.add(manager.enqueue(depth, iterations));
  }

  int stretchDepth = maxDepth + 1;

  int check = TreeNode.itemCheck(TreeNode.bottomUpTree(stretchDepth));
  print(&quot;stretch tree of depth $stretchDepth\t check: $check&quot;);

  TreeNode longLivedTree = TreeNode.bottomUpTree(maxDepth);

  for (int depth = minDepth; depth &lt;= maxDepth; depth += 2) {
    int iterations = 1 &lt;&lt; (maxDepth - depth + minDepth);
    final check = await workFuture.removeAt(0);
    print(&quot;${iterations}\t trees of depth $depth\t check: $check&quot;);
  }

  print(
      &quot;long lived tree of depth $maxDepth\t check: ${TreeNode.itemCheck(longLivedTree)}&quot;);

  sw.stop();
  if (workerDebug) print(sw.elapsedMilliseconds);

  // It takes time to clean up the workers, so just exit instead
  exit(0);
}

class TreeNode {
  final TreeNode left, right;

  const TreeNode([this.left, this.right]);

  static TreeNode bottomUpTree(int depth) {
    return depth &gt; 0
        ? TreeNode(bottomUpTree(depth - 1), bottomUpTree(depth - 1))
        : TreeNode(null, null);
  }

  static int itemCheck(TreeNode node) {
    if (node.left == null) {
      return 1;
    }
    return 1 + itemCheck(node.left) + itemCheck(node.right);
  }
}
    </pre>
  </section>
  <section>
    <h2 id="log">notes, command-line, and program output</h2>
    <pre>
NOTES:
64-bit Ubuntu quad core
Dart VM version: 2.4.0 (Wed Jun 19 11:53:45 2019 +0200) on "linux_x64"



Sat, 20 Jul 2019 17:10:27 GMT

MAKE:
/opt/src/dartsdk-linux-x64-release/dart-sdk/bin/dartanalyzer binarytrees.dartaot-2.dartaot
Analyzing binarytrees.dartaot-2.dartaot...
No issues found!
/opt/src/dartsdk-linux-x64-release/dart-sdk/bin/dart2aot binarytrees.dartaot-2.dartaot binarytrees.dartaot-2.aot

11.33s to complete and log all make actions

COMMAND LINE:
/opt/src/dartsdk-linux-x64-release/dart-sdk/bin/dartaotruntime binarytrees.dartaot-2.aot 21

PROGRAM OUTPUT:
stretch tree of depth 22	 check: 8388607
2097152	 trees of depth 4	 check: 65011712
524288	 trees of depth 6	 check: 66584576
131072	 trees of depth 8	 check: 66977792
32768	 trees of depth 10	 check: 67076096
8192	 trees of depth 12	 check: 67100672
2048	 trees of depth 14	 check: 67106816
512	 trees of depth 16	 check: 67108352
128	 trees of depth 18	 check: 67108736
32	 trees of depth 20	 check: 67108832
long lived tree of depth 21	 check: 4194303
    </pre>
  </section>
</article>
<footer>
  <nav>
    <ul>
      <li><a href="../license.html"><span>3-Clause BSD License</span></a>
    </ul>
  </nav>
</footer>

